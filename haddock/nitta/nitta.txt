-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tool for Hard Real-Time CGRA Processors
--   
--   Kind: research pet project.
--   
--   Project status: early prototype.
--   
--   We develop the tool for generating and programming specialized non-von
--   Neumann CGRA processors used for cyclic execution of control and
--   signal/data processing algorithms. These processors are based on the
--   original Not Instruction Transport Triggered Architecture (NITTA).
--   That allows us to:
--   
--   <ul>
--   <li>Provide high speed and parallel execution of irregular algorithms
--   (where GPU is not applicable) in hard real-time (clock accuracy).</li>
--   <li>Make the processor reconfigurable for different application
--   domains.</li>
--   <li>Provide a high-level language for application developers and fast
--   compilation.</li>
--   </ul>
--   
--   Our future users can resolve the following tasks:
--   
--   <ul>
--   <li>Development of embedded and cyber-physical systems.</li>
--   <li>Hardware and software testing and rapid prototyping (HIL and
--   PIL).</li>
--   <li>Development of programmable accelerators and coprocessors.</li>
--   </ul>
--   
--   Page: <a>https://ryukzak.github.io/projects/nitta/</a>
@package nitta
@version 0.0.0.1


module NITTA.Frontends.XMILE.MathParser
parseXmileEquation :: String -> XMExpr
calculateDefaultValue :: HashMap Text Double -> XMExpr -> Double
data XMExpr
Var :: String -> XMExpr
Val :: Double -> XMExpr
Duo :: XMDuop -> XMExpr -> XMExpr
[xmeOp] :: XMExpr -> XMDuop
[xmeLexpr, xmeRexpr] :: XMExpr -> XMExpr
data XMDuop
Mul :: XMDuop
Div :: XMDuop
Add :: XMDuop
Sub :: XMDuop
instance GHC.Classes.Eq NITTA.Frontends.XMILE.MathParser.XMDuop
instance GHC.Show.Show NITTA.Frontends.XMILE.MathParser.XMDuop
instance GHC.Classes.Eq NITTA.Frontends.XMILE.MathParser.XMExpr
instance GHC.Show.Show NITTA.Frontends.XMILE.MathParser.XMExpr


module NITTA.Frontends.XMILE.DocumentParser
parseDocument :: String -> Content
data Content
Content :: SimSpec -> [Flow] -> [Aux] -> [Stock] -> Content
[xcSimSpecs] :: Content -> SimSpec
[xcFlows] :: Content -> [Flow]
[xcAuxs] :: Content -> [Aux]
[xcStocks] :: Content -> [Stock]
data Stock
Stock :: Text -> XMExpr -> Maybe Text -> Maybe Text -> Stock
[xsName] :: Stock -> Text
[xsEquation] :: Stock -> XMExpr
[xsInflow] :: Stock -> Maybe Text
[xsOutflow] :: Stock -> Maybe Text
data Aux
Aux :: Text -> XMExpr -> Aux
[xaName] :: Aux -> Text
[xaEquation] :: Aux -> XMExpr
data Flow
Flow :: Text -> XMExpr -> Flow
[xfName] :: Flow -> Text
[xfEquation] :: Flow -> XMExpr
data SimSpec
SimSpec :: Double -> Double -> Double -> SimSpec
[xssStart] :: SimSpec -> Double
[xssStop] :: SimSpec -> Double
[xssDt] :: SimSpec -> Double
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.SimSpec
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.SimSpec
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Flow
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Flow
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Aux
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Aux
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Stock
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Stock
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Variables
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Variables
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Model
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Model
instance GHC.Classes.Eq NITTA.Frontends.XMILE.DocumentParser.Content
instance GHC.Show.Show NITTA.Frontends.XMILE.DocumentParser.Content
instance GHC.Classes.Eq (NITTA.Frontends.XMILE.DocumentParser.AlgState v x)
instance GHC.Show.Show (NITTA.Frontends.XMILE.DocumentParser.AlgState v x)


module NITTA.Intermediate.Variable

-- | Variable identifier. Used for simplify type description.
type Var v = (Typeable v, Ord v, IsString v, ToString v, Suffix v, Hashable v)

-- | Type class of something, which is related to variables.
class Variables a v | a -> v

-- | Get all related variables.
variables :: Variables a v => a -> Set v

-- | The type class for variable identifier modifications.
class Suffix v

-- | Make a buffered version of the variable. For example: <tt>"v" -&gt;
--   "v</tt>buf"@
bufferSuffix :: Suffix v => v -> v

-- | Buffer sequence length of a variable (<tt>"v" -&gt; 0; "v</tt>buf"
--   -&gt; 1; "b<tt>buf</tt>buf" -&gt; 2@)
countSuffix :: Suffix v => v -> Int
instance NITTA.Intermediate.Variable.Suffix GHC.Base.String
instance NITTA.Intermediate.Variable.Suffix Data.Text.Internal.Text


module NITTA.Model.Problems.Allocation
data Allocation tag
Allocation :: tag -> tag -> Allocation tag

-- | Tag of the BusNetwork where PU will be allocated
[networkTag] :: Allocation tag -> tag

-- | Tag of the prototype that will be used for allocation
[processUnitTag] :: Allocation tag -> tag
class AllocationProblem u tag | u -> tag
allocationOptions :: AllocationProblem u tag => u -> [Allocation tag]
allocationDecision :: AllocationProblem u tag => u -> Allocation tag -> u
instance GHC.Classes.Eq tag => GHC.Classes.Eq (NITTA.Model.Problems.Allocation.Allocation tag)
instance GHC.Generics.Generic (NITTA.Model.Problems.Allocation.Allocation tag)
instance Data.String.ToString.ToString tag => GHC.Show.Show (NITTA.Model.Problems.Allocation.Allocation tag)


module NITTA.Project.VerilogSnippets
snippetClkGen :: Text
snippetDumpFile :: Text -> Text


-- | Taken as is from Control.Concurrent.Cache of io-memoize package, but
--   with expoted Cache constructor, so we can use it in pattern matching.
--   
--   This was necessary not to rewrite similar functionality. Linter errors
--   were fixed as well.
module NITTA.Synthesis.MlBackend.FixedCache

-- | A thread-safe write-once cache. If you need more functionality, (e.g.
--   multiple write, cache clearing) use an <a>MVar</a> instead.
newtype Cache a
Cache :: MVar (Maybe a) -> Cache a

-- | Create an empty cache.
newCache :: IO (Cache a)

-- | Fetch the value stored in the cache, or call the supplied fallback and
--   store the result, if the cache is empty.
fetch :: Cache a -> IO a -> IO a
instance GHC.Classes.Eq (NITTA.Synthesis.MlBackend.FixedCache.Cache a)


module NITTA.UIBackend.ViewHelperCls

-- | Type class of helpers required for autogeneration of ToJSON and
--   typescript types.
class Viewable t v | t -> v
view :: Viewable t v => t -> v


module NITTA.Utils.Base
unionsMap :: Ord a => (a -> Set a) -> [a] -> Set a
oneOf :: Set c -> c
minimumOn :: (Foldable t, Ord a) => (t -> a) -> t t -> t
maximumOn :: (Foldable t, Ord a) => (t -> a) -> t t -> t
toText :: ToString a => a -> Text
fromText :: IsString a => Text -> a
showText :: Show a => a -> Text
readText :: Read a => Text -> a
vsToStringList :: ToString a => Set a -> [String]
catchToMaybeIO :: IO a -> IO (Maybe a)


module NITTA.Synthesis.MlBackend.ServerInstance
data MlBackendServer
MlBackendServer :: Maybe Text -> Maybe (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> MlBackendServer
[baseUrl] :: MlBackendServer -> Maybe Text
[handles] :: MlBackendServer -> Maybe (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Makes ML backend server available with lazy initialization,
--   memoization and proper cleanup.
withLazyMlBackendServer :: (IO MlBackendServer -> IO c) -> IO c
instance Data.Default.Class.Default NITTA.Synthesis.MlBackend.ServerInstance.MlBackendServer


module NITTA.Intermediate.Value

-- | Type class for representation of processing values. A value should
--   include two parts: data and attribute.
class (Typeable x, Show x, Read x, PrintfArg x, Default x, Integral x, Enum x, Eq x, Num x, Bits x, Validity x, FixedPointCompatible x, ToJSON x) => Val x

-- | data bus width
dataWidth :: Val x => x -> Int

-- | attribute bus width
attrWidth :: Val x => x -> Int

-- | raw representation of data (<tt>Integer</tt>)
rawData :: Val x => x -> Integer

-- | raw representation of attributes (<tt>Integer</tt>)
rawAttr :: Val x => x -> Integer

-- | construct a value from raw data and attributes
fromRaw :: Val x => Integer -> Integer -> x

-- | convert a value to Verilog literal with data
dataLiteral :: Val x => x -> Text

-- | convert a value to Verilog literal with attributes
attrLiteral :: Val x => x -> Text

-- | helper functions to work with values in Verilog (trace and assert)
verilogHelper :: Val x => x -> Text

-- | RE for extraction assertion data from a testbench log
verilogAssertRE :: Val x => x -> Regex
class Default x => DefaultX u x | u -> x
defX :: DefaultX u x => u -> x

-- | Type class for values, which contain information about fractional part
--   of value (for fixed point arithmetics).
class FixedPointCompatible a
scalingFactorPower :: FixedPointCompatible a => a -> Integer
fractionalBitSize :: FixedPointCompatible a => a -> Int
scalingFactor :: (Floating a, FixedPointCompatible a) => a -> a

-- | Minimal and maximal raw value.
minMaxRaw :: (Num b, Val p) => p -> (b, b)

-- | All values with attributes.
data Attr x
Attr :: x -> Bool -> Attr x
[value] :: Attr x -> x
[invalid] :: Attr x -> Bool

-- | Integer number with specific bit width.
newtype IntX (w :: Nat)
IntX :: Integer -> IntX (w :: Nat)
[intX] :: IntX (w :: Nat) -> Integer

-- | Number with fixed point. FX m b where
--   
--   <ul>
--   <li>m the number of magnitude or integer bits</li>
--   <li>b the total number of bits</li>
--   </ul>
--   
--   fxm.b: The "fx" prefix is similar to the above, but uses the word
--   length as the second item in the dotted pair. For example, fx1.16
--   describes a number with 1 magnitude bit and 15 fractional bits in a 16
--   bit word.
newtype FX (m :: Nat) (b :: Nat)
FX :: Integer -> FX (m :: Nat) (b :: Nat)
[rawFX] :: FX (m :: Nat) (b :: Nat) -> Integer
instance GHC.Classes.Ord x => GHC.Classes.Ord (NITTA.Intermediate.Value.Attr x)
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.Intermediate.Value.Attr x)
instance GHC.Classes.Ord (NITTA.Intermediate.Value.IntX w)
instance GHC.Classes.Eq (NITTA.Intermediate.Value.IntX w)
instance GHC.Show.Show (NITTA.Intermediate.Value.IntX w)
instance GHC.Generics.Generic (NITTA.Intermediate.Value.FX m b)
instance GHC.Classes.Ord (NITTA.Intermediate.Value.FX m b)
instance GHC.Classes.Eq (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat b, GHC.TypeNats.KnownNat m) => Data.Validity.Validity (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Read.Read (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => Text.Printf.PrintfArg (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Show.Show (NITTA.Intermediate.Value.FX m b)
instance Data.Default.Class.Default (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Enum.Enum (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Num.Num (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Real.Integral (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Bits.Bits (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => GHC.Real.Real (NITTA.Intermediate.Value.FX m b)
instance (GHC.TypeNats.KnownNat m, GHC.TypeNats.KnownNat b) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.FX m b)
instance GHC.TypeNats.KnownNat m => Data.Validity.Validity (NITTA.Intermediate.Value.IntX m)
instance GHC.Read.Read (NITTA.Intermediate.Value.IntX w)
instance Text.Printf.PrintfArg (NITTA.Intermediate.Value.IntX w)
instance Data.Default.Class.Default (NITTA.Intermediate.Value.IntX w)
instance GHC.Enum.Enum (NITTA.Intermediate.Value.IntX w)
instance GHC.Num.Num (NITTA.Intermediate.Value.IntX w)
instance GHC.Real.Real (NITTA.Intermediate.Value.IntX w)
instance GHC.Real.Integral (NITTA.Intermediate.Value.IntX w)
instance GHC.TypeNats.KnownNat w => GHC.Bits.Bits (NITTA.Intermediate.Value.IntX w)
instance GHC.TypeNats.KnownNat w => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.IntX w)
instance NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.IntX w)
instance Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.IntX w)
instance Data.Validity.Validity x => Data.Validity.Validity (NITTA.Intermediate.Value.Attr x)
instance GHC.Base.Functor NITTA.Intermediate.Value.Attr
instance GHC.Base.Applicative NITTA.Intermediate.Value.Attr
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Value.Attr x)
instance GHC.Read.Read x => GHC.Read.Read (NITTA.Intermediate.Value.Attr x)
instance Text.Printf.PrintfArg x => Text.Printf.PrintfArg (NITTA.Intermediate.Value.Attr x)
instance Data.Default.Class.Default x => Data.Default.Class.Default (NITTA.Intermediate.Value.Attr x)
instance (GHC.Enum.Enum x, Data.Validity.Validity x) => GHC.Enum.Enum (NITTA.Intermediate.Value.Attr x)
instance (GHC.Num.Num x, Data.Validity.Validity x) => GHC.Num.Num (NITTA.Intermediate.Value.Attr x)
instance (GHC.Real.Real x, Data.Validity.Validity x) => GHC.Real.Real (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.Val x => GHC.Real.Integral (NITTA.Intermediate.Value.Attr x)
instance (GHC.Bits.Bits x, Data.Validity.Validity x) => GHC.Bits.Bits (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.Val x => NITTA.Intermediate.Value.Val (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.FixedPointCompatible x => NITTA.Intermediate.Value.FixedPointCompatible (NITTA.Intermediate.Value.Attr x)
instance Data.Aeson.Types.ToJSON.ToJSON x => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Value.Attr x)
instance NITTA.Intermediate.Value.Val GHC.Types.Int
instance NITTA.Intermediate.Value.FixedPointCompatible GHC.Types.Int


module NITTA.Intermediate.Types

-- | Input variable.
newtype I v
I :: v -> I v

-- | Output variable set.
newtype O v
O :: Set v -> O v

-- | Value of variable (constant or initial value).
newtype X x
X :: x -> X x

-- | Box forall functions.
data F v x
[F] :: (Function f v, Patch f (v, v), Locks f v, Show f, Label f, FunctionSimulation f v x, Typeable f, Eq f) => f -> [F v x] -> F v x

-- | Helper for JSON serialization
data FView
FView :: Text -> [Text] -> FView
[fvFun] :: FView -> Text
[fvHistory] :: FView -> [Text]
packF :: (Function f v, Patch f (v, v), Locks f v, Show f, Label f, FunctionSimulation f v x, Typeable f, Eq f) => f -> F v x

-- | Helper for extraction function from existential container <a>F</a>.
castF :: (Typeable f, Typeable v, Typeable x) => F v x -> Maybe (f v x)
functionType :: F v x -> TypeRep

-- | Type class for application algorithm functions.
class Function f v | f -> v

-- | Get all input variables.
inputs :: Function f v => f -> Set v

-- | Get all output variables.
outputs :: Function f v => f -> Set v

-- | Sometimes, one function can cause internal process unit lock for
--   another function.
isInternalLockPossible :: Function f v => f -> Bool

-- | Variable casuality.
data Lock v
Lock :: v -> v -> Lock v
[locked] :: Lock v -> v
[lockBy] :: Lock v -> v

-- | Casuality of variable processing sequence in term of locks.
--   
--   For example: &gt; c := a + b &gt; [ Lock{ locked=c, lockBy=a }, Lock{
--   locked=c, lockBy=b } ]
class Var v => Locks x v | x -> v
locks :: Locks x v => x -> [Lock v]

-- | All input variables locks all output variables.
inputsLockOutputs :: Function f v => f -> [Lock v]

-- | Type class of something, which is related to functions.
class WithFunctions a f | a -> f

-- | Get a list of associated functions.
functions :: WithFunctions a f => a -> [f]

-- | Type class for making fine label for Functions.
class Label a
label :: Label a => a -> String

-- | The type class for function simulation.
class FunctionSimulation f v x | f -> v x

-- | Receive a computational context and return changes (list of varible
--   names and its new values).
simulate :: FunctionSimulation f v x => CycleCntx v x -> f -> [(v, x)]
newtype CycleCntx v x
CycleCntx :: HashMap v x -> CycleCntx v x
[cycleCntx] :: CycleCntx v x -> HashMap v x
data Cntx v x
Cntx :: [CycleCntx v x] -> Map v [x] -> Int -> Cntx v x

-- | all variables on each process cycle
[cntxProcess] :: Cntx v x -> [CycleCntx v x]

-- | sequences of all received values, one value per process cycle
[cntxReceived] :: Cntx v x -> Map v [x]
[cntxCycleNumber] :: Cntx v x -> Int

-- | <pre>
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; putStr $ log2md records
--   | Cycle  | x1   | x2   |
--   |:-------|:-----|:-----|
--   | 1      | 1.2  | 3.4  |
--   | 2      | 3.4  | 2.3  |
--   </pre>
log2md :: ToString a => [HashMap a String] -> String

-- | <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BS
--   
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; BS.putStr $ log2json records
--   [
--       {
--           "x1": 1.2,
--           "x2": 3.4
--       },
--       {
--           "x1": 3.4,
--           "x2": 2.3
--       }
--   ]
--   </pre>
log2json :: ToString a => [HashMap a String] -> ByteString

-- | <pre>
--   &gt;&gt;&gt; import qualified Data.ByteString.Lazy.Char8 as BS
--   
--   &gt;&gt;&gt; let records = map HM.fromList [[("x1"::String,"1.2"::String), ("x2","3.4")], [("x1","3.4"), ("x2","2.3")]]
--   
--   &gt;&gt;&gt; BS.putStr $ log2csv records
--   x1,x2
--   1.2,3.4
--   3.4,2.3
--   </pre>
log2csv :: ToString a => [HashMap a String] -> ByteString

-- | Make sequence of received values '[ Map v x ]'
cntxReceivedBySlice :: Ord v => Cntx v x -> [Map v x]
getCntx :: (Hashable a, ToString a) => CycleCntx a v -> a -> v
updateCntx :: (Hashable v, ToString v) => CycleCntx v x -> [(v, x)] -> Either String (CycleCntx v x)

-- | Patch class allows replacing one variable by another. Especially for
--   algorithm refactor.
class Patch f diff
patch :: Patch f diff => diff -> f -> f

-- | Change set for patch.
--   
--   <pre>
--   &gt;&gt;&gt; Changeset (M.fromList [("a", "b"), ("c", "d")]) (M.fromList [("e", S.fromList ["f", "g"])]) :: Changeset String
--   Changeset{changeI=[(a, b), (c, d)], changeO=[(e, [f, g])]}
--   </pre>
data Changeset v
Changeset :: Map v v -> Map v (Set v) -> Changeset v

-- | change set for input variables (one to one)
[changeI] :: Changeset v -> Map v v

-- | change set for output variables. Many to many relations:
--   
--   <pre>
--   fromList [(a, {x}), (b, {x})] -- several output variables to one
--   fromList [(c, {y, z})] -- one output variable to many
--   </pre>
[changeO] :: Changeset v -> Map v (Set v)

-- | Reverse changeset for patch a process unit options / decision.
reverseDiff :: Ord t => Changeset t -> Changeset t
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.I v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.I v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.O v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.O v)
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.Intermediate.Types.X x)
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Types.X x)
instance GHC.Generics.Generic (NITTA.Intermediate.Types.Lock v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Intermediate.Types.Lock v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.Lock v)
instance GHC.Show.Show NITTA.Intermediate.Types.FView
instance GHC.Generics.Generic NITTA.Intermediate.Types.FView
instance GHC.Generics.Generic (NITTA.Intermediate.Types.CycleCntx v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.F v x) (NITTA.Intermediate.Types.Changeset v)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Types.Changeset v)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Eq (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Types.Function (NITTA.Intermediate.Types.F v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Types.F v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Types.F v x) v
instance GHC.Classes.Ord (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.F v x) (v, v)
instance GHC.Show.Show (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.F v x) v
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Intermediate.Types.F v x) NITTA.Intermediate.Types.FView
instance GHC.Classes.Eq v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.I v) (v, v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Types.O v) (v, v)
instance NITTA.Intermediate.Types.Patch b v => NITTA.Intermediate.Types.Patch [b] v
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Intermediate.Types.Cntx GHC.Base.String x)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.Cntx v x)
instance (Data.String.ToString.ToString v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Types.CycleCntx v x)
instance Data.Default.Class.Default (NITTA.Intermediate.Types.CycleCntx v x)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Intermediate.Types.FView
instance NITTA.Intermediate.Types.Label GHC.Base.String
instance NITTA.Intermediate.Types.Label Data.Text.Internal.Text
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.Lock v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Intermediate.Types.Lock v)
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.O v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.O v) v
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Intermediate.Types.I v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Types.I v) v


module NITTA.UIBackend.VisJS
type VisJS = GraphStructure GraphEdge
algToVizJS :: Label v => [F v x] -> GraphStructure GraphEdge
data GraphStructure v
GraphStructure :: [GraphNode] -> [v] -> GraphStructure v
[$sel:nodes:GraphStructure] :: GraphStructure v -> [GraphNode]
[$sel:edges:GraphStructure] :: GraphStructure v -> [v]
data GraphNode
GraphNode :: Int -> String -> String -> [String] -> String -> String -> String -> String -> GraphNode
[$sel:id:GraphNode] :: GraphNode -> Int
[$sel:label:GraphNode] :: GraphNode -> String
[$sel:function:GraphNode] :: GraphNode -> String
[$sel:history:GraphNode] :: GraphNode -> [String]
[$sel:nodeColor:GraphNode] :: GraphNode -> String
[$sel:nodeShape:GraphNode] :: GraphNode -> String
[$sel:fontSize:GraphNode] :: GraphNode -> String
[$sel:nodeSize:GraphNode] :: GraphNode -> String
data GraphEdge
GraphEdge :: Int -> Int -> String -> String -> String -> GraphEdge
[$sel:to:GraphEdge] :: GraphEdge -> Int
[$sel:from:GraphEdge] :: GraphEdge -> Int
[$sel:label:GraphEdge] :: GraphEdge -> String
[$sel:edgeWidth:GraphEdge] :: GraphEdge -> String
[$sel:fontAllign:GraphEdge] :: GraphEdge -> String
instance GHC.Generics.Generic NITTA.UIBackend.VisJS.GraphEdge
instance GHC.Generics.Generic NITTA.UIBackend.VisJS.GraphNode
instance GHC.Generics.Generic (NITTA.UIBackend.VisJS.GraphStructure v)
instance GHC.Classes.Eq NITTA.UIBackend.VisJS.VertexType
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.VisJS
instance Servant.Docs.Internal.ToSample NITTA.UIBackend.VisJS.VisJS
instance Data.Default.Class.Default NITTA.UIBackend.VisJS.GraphNode
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.GraphNode
instance Data.Default.Class.Default NITTA.UIBackend.VisJS.GraphEdge
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.VisJS.GraphEdge


module NITTA.Model.Time

-- | Shortcut for variable (<tt>v</tt>), value (<tt>x</tt>) and time
--   (<tt>t</tt>) type constrains.
type VarValTime v x t = (Var v, Val x, Time t)
type VarValTimeJSON v x t = (VarValTime v x t, ToJSONKey v, ToJSON v, ToJSON x, ToJSON t)

-- | Shortcut for time type constrain.
type Time t = (Default t, Num t, Bounded t, Ord t, Show t, Typeable t, Enum t, Integral t)

-- | Time constrain for processor activity.
data TimeConstraint t
TimeConstraint :: Interval t -> Interval t -> TimeConstraint t

-- | Inclusive interval, when value available to transfer.
[tcAvailable] :: TimeConstraint t -> Interval t

-- | Inclusive interval, possible for value transfers.
[tcDuration] :: TimeConstraint t -> Interval t

-- | Forgoten implementation of tagged time for speculative if statement.
--   Current - dead code.
data TaggedTime tag t
TaggedTime :: Maybe tag -> t -> TaggedTime tag t
[tTag] :: TaggedTime tag t -> Maybe tag
[tClock] :: TaggedTime tag t -> t
instance GHC.Generics.Generic (NITTA.Model.Time.TimeConstraint t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.Time.TimeConstraint t)
instance GHC.Generics.Generic (NITTA.Model.Time.TaggedTime tag t)
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.Time.TaggedTime tag t)
instance (NITTA.Model.Time.Time t, GHC.Show.Show tag) => GHC.Show.Show (NITTA.Model.Time.TaggedTime tag t)
instance NITTA.Model.Time.Time t => GHC.Show.Show (NITTA.Model.Time.TaggedTime GHC.Base.String t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Enum.Enum t => GHC.Enum.Enum (NITTA.Model.Time.TaggedTime tag t)
instance GHC.Num.Num t => GHC.Enum.Bounded (NITTA.Model.Time.TaggedTime tag t)
instance (GHC.Num.Num t, GHC.Show.Show tag, GHC.Classes.Eq tag) => GHC.Num.Num (NITTA.Model.Time.TaggedTime tag t)
instance (GHC.Show.Show t, GHC.Classes.Eq t, GHC.Enum.Bounded t) => GHC.Show.Show (NITTA.Model.Time.TimeConstraint t)
instance Data.Aeson.Types.ToJSON.ToJSON tp => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Time.TimeConstraint tp)
instance Data.Aeson.Types.ToJSON.ToJSON t => Data.Aeson.Types.ToJSON.ToJSON (Numeric.Interval.NonEmpty.Internal.Interval t)


module NITTA.Model.Problems.Endpoint
data EndpointSt v tp
EndpointSt :: EndpointRole v -> tp -> EndpointSt v tp

-- | use processor unit as source or target of data
[epRole] :: EndpointSt v tp -> EndpointRole v

-- | time of operation
[epAt] :: EndpointSt v tp -> tp
class EndpointProblem u v t | u -> v t
endpointOptions :: EndpointProblem u v t => u -> [EndpointSt v (TimeConstraint t)]
endpointDecision :: EndpointProblem u v t => u -> EndpointSt v (Interval t) -> u
data EndpointRole v

-- | get data from PU
Source :: Set v -> EndpointRole v

-- | put data to PU
Target :: v -> EndpointRole v

-- | The simplest way to convert an endpoint synthesis option to a endpoint
--   decision.
endpointOptionToDecision :: (Num a, Ord a) => EndpointSt v (TimeConstraint a) -> EndpointSt v (Interval a)
isSource :: EndpointSt v tp -> Bool
isTarget :: EndpointSt v tp -> Bool
isSubroleOf :: Ord a => EndpointRole a -> EndpointRole a -> Bool
setAt :: tp -> EndpointSt v tp -> EndpointSt v tp
updAt :: (t -> tp) -> EndpointSt v t -> EndpointSt v tp
instance GHC.Generics.Generic (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Generics.Generic (NITTA.Model.Problems.Endpoint.EndpointSt v tp)
instance NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Endpoint.EndpointSt v t) v
instance (Data.String.ToString.ToString v, NITTA.Model.Time.Time t) => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v (NITTA.Model.Time.TimeConstraint t))
instance (Data.String.ToString.ToString v, NITTA.Model.Time.Time t) => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v (Numeric.Interval.NonEmpty.Internal.Interval t))
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Problems.Endpoint.EndpointSt v tp) (NITTA.Intermediate.Types.Changeset v)
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON tp) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Problems.Endpoint.EndpointSt v tp)
instance Data.String.ToString.ToString v => GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointRole v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Problems.Endpoint.EndpointRole v) (NITTA.Intermediate.Types.Changeset v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Endpoint.EndpointRole v) v
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Problems.Endpoint.EndpointRole v)


module NITTA.Model.ProcessorUnits.Types

-- | Class for processor unit tag or "name"
class (Typeable tag, Ord tag, ToString tag, IsString tag, Semigroup tag) => UnitTag tag

-- | Whether the value can be used as a template or not
isTemplate :: UnitTag tag => tag -> Bool

-- | Create tag from the template and index
fromTemplate :: UnitTag tag => tag -> String -> tag

-- | Process unit - part of NITTA process with can execute a function from
--   intermediate representation:
--   
--   <ol>
--   <li>get function for execution (<a>tryBind</a>);</li>
--   <li>store computational process description (<a>process</a>);</li>
--   <li>other features implemented by different type classes (see above
--   and in <a>NITTA.Model.Problems</a>).</li>
--   </ol>
class VarValTime v x t => ProcessorUnit u v x t | u -> v x t
tryBind :: ProcessorUnit u v x t => F v x -> u -> Either String u
process :: ProcessorUnit u v x t => u -> Process t (StepInfo v x t)

-- | Indicates what type of parallelism is supported by
--   <a>ProcessorUnit</a>
parallelismType :: ProcessorUnit u v x t => u -> ParallelismType

-- | Provide the processor unit size. At the moment it's just the number of
--   subprocessors
puSize :: ProcessorUnit u v x t => u -> Float
bind :: ProcessorUnit u v x t => F v x -> u -> u
allowToProcess :: ProcessorUnit b v x t => F v x -> b -> Bool
class NextTick u t | u -> t
nextTick :: NextTick u t => u -> t

-- | Processor unit parallelism type
data ParallelismType

-- | All operations can be performed in parallel mode
Full :: ParallelismType

-- | All operations can be performed in pipeline mode
Pipeline :: ParallelismType

-- | Other processor units
None :: ParallelismType

-- | Computational process description. It was designed in ISO 15926 style,
--   with separated data and relations storage.
data Process t i
Process :: [Step t i] -> [Relation] -> t -> ProcessStepID -> Process t i

-- | All process steps desctiption.
[steps] :: Process t i -> [Step t i]

-- | List of relationships between process steps (see <a>Relation</a>).
[relations] :: Process t i -> [Relation]

-- | Next tick for instruction. Note: instruction /= endpoint.
[nextTick_] :: Process t i -> t

-- | Next process step ID
[nextUid] :: Process t i -> ProcessStepID

-- | Unique ID of a process step. Uniquity presented only inside PU.
type ProcessStepID = Int

-- | Process step representation
data Step t i
Step :: ProcessStepID -> Interval t -> i -> Step t i

-- | uniq (inside single the process unit) step ID
[pID] :: Step t i -> ProcessStepID

-- | step time
[pInterval] :: Step t i -> Interval t

-- | step description
[pDesc] :: Step t i -> i

-- | Informative process step description at a specific process level.
data StepInfo v x t

-- | CAD level step
[CADStep] :: String -> StepInfo v x t

-- | Apply refactoring
[RefactorStep] :: (Typeable ref, Show ref, Eq ref) => ref -> StepInfo v x t

-- | intermidiate level step (function execution)
[IntermediateStep] :: F v x -> StepInfo v x t

-- | endpoint level step (source or target)
[EndpointRoleStep] :: EndpointRole v -> StepInfo v x t

-- | process unit instruction (depends on process unit type)
[InstructionStep] :: (Show (Instruction pu), Typeable (Instruction pu)) => Instruction pu -> StepInfo v x t

-- | wrapper for nested process unit step (used for networks)
[NestedStep] :: UnitTag tag => tag -> Step t (StepInfo v x t) -> StepInfo v x t

-- | Process unit allocation step
[AllocationStep] :: (Typeable a, Show a, Eq a) => a -> StepInfo v x t

-- | Relations between process steps.
data Relation

-- | Vertical relationships (up and down). For example, the intermediate
--   step (function execution) can be translated to a sequence of endpoint
--   steps (receiving and sending variable), and process unit instructions.
Vertical :: ProcessStepID -> Relation
[vUp, vDown] :: Relation -> ProcessStepID

-- | Horizontal relationships (on one level). For example, we bind the
--   function and apply the refactoring. The binding step should be
--   connected to refactoring steps, including new binding steps.
Horizontal :: ProcessStepID -> Relation
[hPrev, hNext] :: Relation -> ProcessStepID
descent :: StepInfo v x t -> StepInfo v x t
whatsHappen :: Ord a => a -> Process a i -> [Step a i]
extractInstructionAt :: (ProcessorUnit u v x t, Typeable u) => u -> t -> [Instruction u]

-- | Shift <tt>nextTick</tt> value if it is not zero on a specific offset.
--   Use case: The processor unit has buffered output, so we should provide
--   <tt>oe</tt> signal for one tick before data actually send to the bus.
--   That raises the following cases:
--   
--   <ol>
--   <li>First usage. We can receive value immediately on nextTick<pre>tick
--   | Endpoint | Instruction | 0 | Target "c" | WR | &lt;- nextTick
--   </pre></li>
--   <li>Not first usage. We need to wait for one tick from the last
--   instruction due to the offset between instruction and data
--   transfers.<pre>tick | Endpoint | Instruction | 8 | | OE | 9 | Source
--   ["b"] | | &lt;- nextTick 10 | Target "c" | WR | </pre></li>
--   </ol>
withShift :: (Eq a, Num a) => a -> a -> a
isRefactorStep :: StepInfo v x t -> Bool
isAllocationStep :: StepInfo v x t -> Bool

-- | Type class for controllable units. Defines two level of a unit
--   behaviour representation (see ahead).
class Controllable pu where {
    data Instruction pu :: Type;
    
    -- | Microcode desctibe controll signals on each mUnit cycle (without
    --   exclusion).
    data Microcode pu :: Type;
}

-- | Zip port signal tags and value.
zipSignalTagsAndValues :: Controllable pu => Ports pu -> Microcode pu -> [(SignalTag, SignalValue)]

-- | Get list of used control signal tags.
usedPortTags :: Controllable pu => Ports pu -> [SignalTag]

-- | Take signal tags from inifinite list of tags.
takePortTags :: Controllable pu => [SignalTag] -> pu -> Ports pu
newtype SignalTag
SignalTag :: Text -> SignalTag
[signalTag] :: SignalTag -> Text

-- | Decoding microcode from a simple instruction (microcode don't change
--   over time).
--   
--   TODO: Generalize that class for all process units, including networks.
class UnambiguouslyDecode pu
decodeInstruction :: UnambiguouslyDecode pu => Instruction pu -> Microcode pu

-- | Type class of processor units with control ports.
class Connected pu where {
    
    -- | A processor unit control ports (signals, flags).
    data Ports pu :: Type;
}

-- | Getting microcode value at a specific time.
class ByTime pu t | pu -> t
microcodeAt :: ByTime pu t => pu -> t -> Microcode pu

-- | Control line value.
data SignalValue

-- | undefined by design (<tt>x</tt>)
Undef :: SignalValue

-- | boolean (`0` or `1`)
Bool :: Bool -> SignalValue

-- | broken value (<tt>x</tt>) by data colision
BrokenSignal :: SignalValue
(+++) :: SignalValue -> SignalValue -> SignalValue

-- | Type class of processor units with IO ports.
class IOConnected pu where {
    data IOPorts pu :: Type;
}

-- | External input ports, which go outside of NITTA mUnit.
inputPorts :: IOConnected pu => IOPorts pu -> Set InputPortTag

-- | External output ports, which go outside of NITTA mUnit.
outputPorts :: IOConnected pu => IOPorts pu -> Set OutputPortTag

-- | External output ports, which go outside of NITTA mUnit.
inoutPorts :: IOConnected pu => IOPorts pu -> Set InoutPortTag
newtype InputPortTag
InputPortTag :: Text -> InputPortTag
[inputPortTag] :: InputPortTag -> Text
newtype OutputPortTag
OutputPortTag :: Text -> OutputPortTag
[outputPortTag] :: OutputPortTag -> Text
newtype InoutPortTag
InoutPortTag :: Text -> InoutPortTag
[inoutPortTag] :: InoutPortTag -> Text
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.ParallelismType
instance GHC.Generics.Generic NITTA.Model.ProcessorUnits.Types.ParallelismType
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.ParallelismType
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.Types.Step t i)
instance (GHC.Show.Show t, GHC.Show.Show i) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Step t i)
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Generics.Generic NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.Relation
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.Types.Process t i)
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.SignalTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.SignalTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.InputPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.InputPortTag
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Classes.Ord NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.InoutPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.OutputPortTag
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.InputPortTag
instance NITTA.Model.ProcessorUnits.Types.ProcessorUnit u v x t => NITTA.Model.ProcessorUnits.Types.NextTick u t
instance (GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction pu), Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode pu), NITTA.Model.ProcessorUnits.Types.ProcessorUnit pu v x t, NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode pu, Data.Typeable.Internal.Typeable pu) => NITTA.Model.ProcessorUnits.Types.ByTime pu t
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Types.Process t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Intermediate.Types.F v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.ProcessorUnits.Types.Step t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Intermediate.Types.Changeset v)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Step t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t))) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.ProcessorUnits.Types.StepInfo v x t) (NITTA.Intermediate.Types.Changeset v)
instance Data.Default.Class.Default NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.SignalValue
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Types.SignalTag
instance (NITTA.Model.Time.Time t, GHC.Show.Show i) => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Types.Process t i)
instance (Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.Types.Process t i)
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Process t i)
instance NITTA.Model.ProcessorUnits.Types.NextTick (NITTA.Model.ProcessorUnits.Types.Process t si) t
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.ProcessorUnits.Types.Relation
instance (Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.Types.Step t i)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.ProcessorUnits.Types.ParallelismType
instance NITTA.Model.ProcessorUnits.Types.UnitTag Data.Text.Internal.Text
instance NITTA.Model.ProcessorUnits.Types.UnitTag GHC.Base.String


module NITTA.Model.Problems.Dataflow

-- | Dataflow option (<tt>tp ~ TimeConstraint t</tt>) or decision (<tt>tp Z
--   Interval t</tt>) statement. Describe sending data between processor
--   units over a network. Any <a>DataflowSt</a> has implicently linked
--   <a>NITTA.Model.Problems.Endpoint</a>.
data DataflowSt tag v tp
DataflowSt :: (tag, EndpointSt v tp) -> [(tag, EndpointSt v tp)] -> DataflowSt tag v tp

-- | A source processor unit of data flow transaction, and it's time
--   constrains which defines when data can be sended.
[dfSource] :: DataflowSt tag v tp -> (tag, EndpointSt v tp)

-- | All possible targets of dataflow transaction.
[dfTargets] :: DataflowSt tag v tp -> [(tag, EndpointSt v tp)]

-- | Implemented for any things, which can send data between processor
--   units over the network.
class DataflowProblem u tag v t | u -> tag v t
dataflowOptions :: DataflowProblem u tag v t => u -> [DataflowSt tag v (TimeConstraint t)]
dataflowDecision :: DataflowProblem u tag v t => u -> DataflowSt tag v (Interval t) -> u

-- | Convert dataflow option to decision.
dataflowOption2decision :: Time t => DataflowSt tag v (TimeConstraint t) -> DataflowSt tag v (Interval t)
instance GHC.Generics.Generic (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp)
instance (Data.String.ToString.ToString tag, GHC.Show.Show (NITTA.Model.Problems.Endpoint.EndpointSt v tp)) => GHC.Show.Show (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp)
instance GHC.Classes.Ord v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Dataflow.DataflowSt tag v tp) v


module NITTA.Model.Problems.Bind
data Bind tag v x
SingleBind :: tag -> F v x -> Bind tag v x
GroupBind :: Bool -> Map tag [F v x] -> Bind tag v x
[isObviousBinds] :: Bind tag v x -> Bool
[bindGroup] :: Bind tag v x -> Map tag [F v x]
class BindProblem u tag v x | u -> tag v x
bindOptions :: BindProblem u tag v x => u -> [Bind tag v x]
bindDecision :: BindProblem u tag v x => u -> Bind tag v x -> u
binds2bindGroup :: UnitTag tag => [(tag, F v x)] -> Map tag [F v x]
instance GHC.Classes.Eq tag => GHC.Classes.Eq (NITTA.Model.Problems.Bind.Bind tag v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Bind.Bind tag v x)
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => GHC.Show.Show (NITTA.Model.Problems.Bind.Bind tag v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Problems.Bind.Bind tab v x) v
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Model.Problems.Bind.Bind tag v x) (NITTA.Intermediate.Types.F v x)


module NITTA.Intermediate.Functions.Accum
newtype Acc v x
Acc :: [Action v] -> Acc v x
[$sel:actions:Acc] :: Acc v x -> [Action v]
data Action v
Push :: Sign -> I v -> Action v
Pull :: O v -> Action v
data Sign
Plus :: Sign
Minus :: Sign

-- | Create function with type F of Acc
acc :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Num x, Typeable v, Typeable x) => [Action v] -> F v x

-- | Special function for generating Acc from string, examples in tests
accFromStr :: (Num x, Typeable x) => String -> F Text x
isPull :: Action v -> Bool
isPush :: Action v -> Bool
instance GHC.Classes.Eq NITTA.Intermediate.Functions.Accum.Sign
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Accum.Action v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Accum.Acc v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Accum.Acc v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Accum.Acc v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Accum.Acc v x) v
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Accum.Acc v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Accum.Acc v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Accum.Acc v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Accum.Action v)
instance NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.Functions.Accum.Action v) v
instance GHC.Show.Show NITTA.Intermediate.Functions.Accum.Sign


-- | Library of functions for an intermediate algorithm representation.
--   Execution relations between functions and process units are
--   many-to-many.
--   
--   <ul>
--   <li><i><tt>function (functional block)</tt></i> atomic operation in
--   intermediate algorithm representation. Function has zero or many
--   inputs and zero or many output. Function can contains state between
--   process cycles.</li>
--   </ul>
module NITTA.Intermediate.Functions
data Add v x
Add :: I v -> I v -> O v -> Add v x
add :: (Var v, Val x) => v -> v -> [v] -> F v x
data Division v x
Division :: I v -> O v -> Division v x
[$sel:denom:Division, $sel:numer:Division] :: Division v x -> I v
[$sel:quotient:Division, $sel:remain:Division] :: Division v x -> O v
division :: (Var v, Val x) => v -> v -> [v] -> [v] -> F v x
data Multiply v x
Multiply :: I v -> I v -> O v -> Multiply v x
multiply :: (Var v, Val x) => v -> v -> [v] -> F v x

-- | Functional unit that implements logic shift operations
data ShiftLR v x
ShiftL :: Int -> I v -> O v -> ShiftLR v x
ShiftR :: Int -> I v -> O v -> ShiftLR v x
shiftL :: (Var v, Val x) => Int -> v -> [v] -> F v x
shiftR :: (Var v, Val x) => Int -> v -> [v] -> F v x
data Sub v x
Sub :: I v -> I v -> O v -> Sub v x
sub :: (Var v, Val x) => v -> v -> [v] -> F v x
data Neg v x
Neg :: I v -> O v -> Neg v x
neg :: (Var v, Val x) => v -> [v] -> F v x
data Constant v x
Constant :: X x -> O v -> Constant v x
constant :: (Var v, Val x) => x -> [v] -> F v x
isConst :: (Typeable v, Typeable x) => F v x -> Bool

-- | Loop -- function for transfer data between computational cycles. Let
--   see the simple example with the following implementation of the
--   Fibonacci algorithm.
--   
--   Data flow graph:
--   
--   <pre>
--       +---------------------------------+
--       |                                 |
--       v                                 |
--   +------+                          b2  |
--   | Loop |      b1_1  +-----+    +------+
--   +------+----+------&gt;|     |    |
--               | a1    | sum +----+
--   +------+-----------&gt;|     |
--   | Loop |    |       +-----+      b1_2
--   +------+    +-------------------------+
--       ^                                 |
--       |                                 |
--       +---------------------------------+
--   </pre>
--   
--   Lua source code:
--   
--   <pre>
--   function fib(a1, b1)
--       b2 = a1 + b1
--       fib(b1, b2)
--   end
--   fib(0, 1)
--   </pre>
--   
--   Data flow defines computation for a single computational cycle. But a
--   controller should repeat the algorithm infinite times, and usually, it
--   is required to transfer data between cycles. <a>Loop</a> allows doing
--   that. At first cycle, <a>Loop</a> function produces an initial value
--   (`X x`), after that on each cycle <a>Loop</a> produces a variable
--   value from the previous cycle, and consumes a new value at the end of
--   the cycle.
--   
--   Computational process:
--   
--   <pre>
--            ][                 Cycle 1                 ][                Cycle 2                  ]
--            ][                                         ][                                         ]
--   initial  ][ ---+                          b2   +--- ][ ---+                          b2   +--- ]
--    value   ][ op |      b1_1  +-----+    +------&gt;| Lo ][ op |      b1_1  +-----+    +------&gt;| Lo ]
--    is a    ][ ---+----+------&gt;|     |    |       +--- ][ ---+----+------&gt;|     |    |       +--- ]
--   part of  ][         |       | sum +----+            ][         |       | sum +----+            ]
--   software ][ ---+-----------&gt;|     |            +--- ][ ---+-----------&gt;|     |            +--- ]
--            ][ op |    |       +-----+     b1_2   | Lo ][ op |    |       +-----+      b1_2  | Lo ]
--            ][ ---+    +-------------------------&gt;+--- ][ ---+    +-------------------------&gt;+--- ]
--            ][                                         ][                                         ]
--   </pre>
--   
--   Similation data:
--   
--   TODO: table
--   
--   In practice, Loop function supported by Fram processor unit in the
--   following way: Loop function should be prepared before execution by
--   automatical refactor <tt>BreakLoop</tt>, which replace Loop by
--   <tt>LoopEnd</tt> and <tt>LoopBegin</tt>.
data Loop v x
Loop :: X x -> O v -> I v -> Loop v x
loop :: (Var v, Val x) => x -> v -> [v] -> F v x
isLoop :: (Typeable v, Typeable x) => F v x -> Bool
data LoopEnd v x
LoopEnd :: Loop v x -> I v -> LoopEnd v x
data LoopBegin v x
LoopBegin :: Loop v x -> O v -> LoopBegin v x
data Buffer v x
Buffer :: I v -> O v -> Buffer v x
buffer :: (Var v, Val x) => v -> [v] -> F v x
newtype Receive v x
Receive :: O v -> Receive v x
receive :: (Var v, Val x) => [v] -> F v x
newtype Send v x
Send :: I v -> Send v x
send :: (Var v, Val x) => v -> F v x

-- | Special function for negative tests only.
data BrokenBuffer v x
BrokenBuffer :: I v -> O v -> BrokenBuffer v x
brokenBuffer :: (Var v, Val x) => v -> [v] -> F v x
data Compare v x
Compare :: CmpOp -> I v -> I v -> O v -> Compare v x
data CmpOp
CmpEq :: CmpOp
CmpLt :: CmpOp
CmpLte :: CmpOp
CmpGt :: CmpOp
CmpGte :: CmpOp
cmp :: (Var v, Val x) => CmpOp -> v -> v -> [v] -> F v x
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.Loop v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.LoopBegin v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.LoopEnd v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Buffer v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Add v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Sub v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Multiply v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Division v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Neg v x)
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Intermediate.Functions.Constant v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.ShiftLR v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Send v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Receive v x)
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance GHC.Generics.Generic NITTA.Intermediate.Functions.CmpOp
instance Data.Data.Data NITTA.Intermediate.Functions.CmpOp
instance GHC.Show.Show NITTA.Intermediate.Functions.CmpOp
instance GHC.Classes.Eq NITTA.Intermediate.Functions.CmpOp
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Intermediate.Functions.Compare v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Compare v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Compare v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Compare v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Compare v x) v
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Compare v x) v x
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Compare v x) v
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.BrokenBuffer v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.BrokenBuffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.BrokenBuffer v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.BrokenBuffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.BrokenBuffer v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Receive v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Receive v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Receive v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Receive v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Receive v x) v
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Receive v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Send v x)
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Send v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Send v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Send v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Send v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Send v x) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.ShiftLR v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.ShiftLR v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.ShiftLR v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.ShiftLR v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.ShiftLR v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Bits.Bits x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.ShiftLR v x) v x
instance GHC.Show.Show x => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Constant v x)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.Constant v x)
instance (GHC.Show.Show x, GHC.Classes.Eq x, Data.Typeable.Internal.Typeable x) => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Constant v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Constant v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Constant v x) v
instance NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Constant v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Neg v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Neg v x)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Neg v x) v
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Neg v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Neg v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Neg v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Division v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Division v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Division v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Division v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Division v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Real.Integral x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Division v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Multiply v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Multiply v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Multiply v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Multiply v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Multiply v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Multiply v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Sub v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Sub v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Sub v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Sub v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Sub v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Sub v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Add v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Add v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Add v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Add v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Add v x) v
instance (NITTA.Intermediate.Variable.Var v, GHC.Num.Num x) => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Add v x) v x
instance NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Buffer v x)
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Intermediate.Functions.Buffer v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Buffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Buffer v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Buffer v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Buffer v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.LoopEnd v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.LoopEnd v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.LoopEnd v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.LoopEnd v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.LoopEnd v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.LoopEnd v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.LoopBegin v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.LoopBegin v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.LoopBegin v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.LoopBegin v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.LoopBegin v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.LoopBegin v x) v x
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Intermediate.Functions.Loop v x)
instance (NITTA.Intermediate.Variable.Var v, GHC.Show.Show x) => NITTA.Intermediate.Types.Label (NITTA.Intermediate.Functions.Loop v x)
instance NITTA.Intermediate.Types.Function (NITTA.Intermediate.Functions.Loop v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Patch (NITTA.Intermediate.Functions.Loop v x) (v, v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Intermediate.Functions.Loop v x) v
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.FunctionSimulation (NITTA.Intermediate.Functions.Loop v x) v x


-- | Possible deadlocks (recognized in <a>Bus</a>):
--   
--   <ul>
--   <li>selfsending;</li>
--   </ul>
--   
--   <pre>
--                   source1
--   DoubleLoopOut--b1--+--b2--&gt; DoubleLoopIn
--              |       +------&gt; Send
--              |
--              +------b3------&gt; DoubleLoopIn
--                   source2
--   
--   Possible buffers: b1, b2, b3
--   </pre>
--   
--   <ul>
--   <li>classical deadlock betweeb two function on same PU.</li>
--   </ul>
--   
--   <pre>
--   a + b = c ---+----&gt; c + d = e ---&gt; e * c = f
--                |                         ^
--                +-------------b1----------+
--   </pre>
--   
--   ResolveDeadlock example:
--   
--   <pre>
--   ResolveDeadlock [a, b]
--   </pre>
--   
--   before:
--   
--   <pre>
--   f1 :: (...) -&gt; ([a, b])
--   f2 :: (a, ...) -&gt; (...)
--   f3 :: (b, ...) -&gt; (...)
--   </pre>
--   
--   f1, f2 and f3 process on same process unit. In this case, we have
--   deadlock, which can be fixed by insertion of buffer between functions.
--   
--   after:
--   
--   <pre>
--   f1 :: (...) -&gt; ([a@buf])
--   buffer :: a@buf -&gt; ([a, b])
--   f2 :: (a, ...) -&gt; (...)
--   f3 :: (b, ...) -&gt; (...)
--   </pre>
module NITTA.Model.Problems.Refactor.ResolveDeadlock
data ResolveDeadlock v x
ResolveDeadlock :: F v x -> Changeset v -> ResolveDeadlock v x
[newBuffer] :: ResolveDeadlock v x -> F v x
[changeset] :: ResolveDeadlock v x -> Changeset v
class ResolveDeadlockProblem u v x | u -> v x
resolveDeadlockOptions :: ResolveDeadlockProblem u v x => u -> [ResolveDeadlock v x]
resolveDeadlockDecision :: ResolveDeadlockProblem u v x => u -> ResolveDeadlock v x -> u
resolveDeadlock :: (Var v, Val x) => Set v -> ResolveDeadlock v x

-- | The constant, which restrict maximum length of a buffer sequence.
maxBufferStack :: Int
instance GHC.Classes.Eq v => GHC.Classes.Eq (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)
instance (Data.Typeable.Internal.Typeable v, GHC.Classes.Ord v, Data.String.IsString v, Data.String.ToString.ToString v, NITTA.Intermediate.Variable.Suffix v, Data.Hashable.Class.Hashable v) => GHC.Show.Show (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x)


module NITTA.Model.Problems.Refactor.OptimizeAccum

-- | OptimizeAccum example:
--   
--   <pre>
--   OptimizeAccum [+a +b =&gt; tmp1; +tmp1 +c =&gt; res] [+a +b +c =&gt; d]
--   </pre>
--   
--   before:
--   
--   <pre>
--   [+a +b =&gt; tmp1; +tmp1 +c =&gt; res]
--   </pre>
--   
--   after:
--   
--   <pre>
--   [+a +b +c =&gt; res]
--   </pre>
--   
--   <h2>Doctest optimize example</h2>
--   
--   <pre>
--   &gt;&gt;&gt; let a = constant 1 ["a"]
--   
--   &gt;&gt;&gt; let b = constant 2 ["b"]
--   
--   &gt;&gt;&gt; let c = constant 3 ["c"]
--   
--   &gt;&gt;&gt; let tmp1 = add "a" "b" ["tmp1"]
--   
--   &gt;&gt;&gt; let res = add "tmp1" "c" ["res"]
--   
--   &gt;&gt;&gt; let loopRes = loop 1 "e" ["res"]
--   
--   &gt;&gt;&gt; let fs = [a, b, c, tmp1, res, loopRes] :: [F String Int]
--   
--   &gt;&gt;&gt; optimizeAccumDecision fs $ head $ optimizeAccumOptions fs
--   [Acc(+a +b +c = res),const(1) = a,const(2) = b,const(3) = c,loop(1, e) = res]
--   </pre>
data OptimizeAccum v x
OptimizeAccum :: [F v x] -> [F v x] -> OptimizeAccum v x
[refOld] :: OptimizeAccum v x -> [F v x]
[refNew] :: OptimizeAccum v x -> [F v x]
class OptimizeAccumProblem u v x | u -> v x

-- | Function takes algorithm in <tt>DataFlowGraph</tt> and return list of
--   <tt>Refactor</tt> that can be done
optimizeAccumOptions :: OptimizeAccumProblem u v x => u -> [OptimizeAccum v x]

-- | Function takes <a>OptimizeAccum</a> and modify <tt>DataFlowGraph</tt>
optimizeAccumDecision :: OptimizeAccumProblem u v x => u -> OptimizeAccum v x -> u
instance GHC.Classes.Eq (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance GHC.Show.Show (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem [NITTA.Intermediate.Types.F v x] v x


-- | <h2>ASCII digram</h2>
--   
--   Before compile-time eval optimization
--   
--   <pre>
--   +------------------+
--   |                  |         +-------------------------+
--   | Constant 2 "a"   |         |                         |
--   |                  +--------&gt;+                         |      +--------------+
--   +------------------+         |                         |      |              |
--                                |   Add "a" "b" ["res"]   +-----&gt;+    ......    |
--   +------------------+         |                         |      |              |
--   |                  +--------&gt;+                         |      +--------------+
--   | Constant 3 "b1"  |         |                         |
--   |                  |         +-------------------------+
--   +------------------+
--   </pre>
--   
--   After compile-time eval optimization
--   
--   <pre>
--   +------------------+         +--------------+
--   |                  |         |              |
--   | Constant 5 "res" +--------&gt;+    ......    |
--   |                  |         |              |
--   +------------------+         +--------------+
--   </pre>
--   
--   <h2>Example from ASCII diagram</h2>
--   
--   <pre>
--   &gt;&gt;&gt; let a = constant 1 ["a"]
--   
--   &gt;&gt;&gt; let b = constant 2 ["b"]
--   
--   &gt;&gt;&gt; let res = add "a" "b" ["res"]
--   
--   &gt;&gt;&gt; loopRes = loop 1 "e" ["res"]
--   
--   &gt;&gt;&gt; let fs = [a, b, res, loopRes] :: [F String Int]
--   
--   &gt;&gt;&gt; constantFoldingDecision fs $ head $ constantFoldingOptions fs
--   [loop(1, e) = res,const(3) = res]
--   </pre>
module NITTA.Model.Problems.Refactor.ConstantFolding
data ConstantFolding v x
ConstantFolding :: [F v x] -> [F v x] -> ConstantFolding v x
[cRefOld] :: ConstantFolding v x -> [F v x]
[cRefNew] :: ConstantFolding v x -> [F v x]
class ConstantFoldingProblem u v x | u -> v x

-- | Function takes algorithm in <tt>DataFlowGraph</tt> and return list of
--   optimizations that can be done
constantFoldingOptions :: ConstantFoldingProblem u v x => u -> [ConstantFolding v x]

-- | Function takes <a>ConstantFolding</a> and modify
--   <tt>DataFlowGraph</tt>
constantFoldingDecision :: ConstantFoldingProblem u v x => u -> ConstantFolding v x -> u
instance GHC.Classes.Eq (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance GHC.Show.Show (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem [NITTA.Intermediate.Types.F v x] v x


-- | BreakLoop example:
--   
--   <pre>
--   BreakLoop x o i
--   </pre>
--   
--   before:
--   
--   <pre>
--   l@( Loop (X x) (O o) (I i) )
--   </pre>
--   
--   after:
--   
--   <pre>
--   LoopEnd l (I i)
--   LoopBegin l (O o)
--   </pre>
--   
--   For more details: <a>Loop</a>
module NITTA.Model.Problems.Refactor.BreakLoop
data BreakLoop v x
BreakLoop :: x -> Set v -> v -> BreakLoop v x

-- | initial looped value
[loopX] :: BreakLoop v x -> x

-- | output variables
[loopO] :: BreakLoop v x -> Set v

-- | input variable
[loopI] :: BreakLoop v x -> v
class BreakLoopProblem u v x | u -> v x
breakLoopOptions :: BreakLoopProblem u v x => u -> [BreakLoop v x]
breakLoopDecision :: BreakLoopProblem u v x => u -> BreakLoop v x -> u
recLoop :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
recLoopIn :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
recLoopOut :: (Hashable v, Suffix v, ToString v, IsString v, Ord v, Show x, Typeable v, Typeable x, Eq x) => BreakLoop v x -> F v x
instance (GHC.Classes.Eq x, GHC.Classes.Eq v) => GHC.Classes.Eq (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)
instance GHC.Generics.Generic (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => GHC.Show.Show (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x)


-- | Some times, CAD can not synthesis a target system because of a
--   features of an algorithm and microarchitecture (too less process
--   units, too many functions, too complicated algorithm).
--   
--   In this case user can manually add some tweaks to the algorithm, but
--   for that he should be an expert with deep understanding of NITTA
--   project. Of course, it is not acceptable. This module defines type of
--   that tweaks.
module NITTA.Model.Problems.Refactor

module NITTA.Model.Problems


module NITTA.Intermediate.DataFlow

-- | Data flow graph - intermediate representation of application
--   algorithm. Right now can be replaced by <tt>[F v x]</tt>, but for
--   future features like conduction statement, we don't do that.
data DataFlowGraph v x
DFLeaf :: F v x -> DataFlowGraph v x
DFCluster :: [DataFlowGraph v x] -> DataFlowGraph v x

-- | Convert <tt>[ F v x ]</tt> to <a>DataFlowGraph</a>.
fsToDataFlowGraph :: [F v x] -> DataFlowGraph v x
addFuncToDataFlowGraph :: F v x -> DataFlowGraph v x -> DataFlowGraph v x
instance GHC.Generics.Generic (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance GHC.Show.Show (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance Data.Default.Class.Default (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance GHC.Classes.Eq (NITTA.Intermediate.DataFlow.DataFlowGraph v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Intermediate.DataFlow.DataFlowGraph v x) (NITTA.Intermediate.Types.F v x)
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x
instance NITTA.Intermediate.Variable.Var v => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Intermediate.DataFlow.DataFlowGraph v x) v x


module NITTA.Frontends.Common
data FrontendResult v x
FrontendResult :: DataFlowGraph v x -> [TraceVar] -> ([HashMap v x] -> [HashMap String String]) -> FrontendResult v x
[frDataFlow] :: FrontendResult v x -> DataFlowGraph v x
[frTrace] :: FrontendResult v x -> [TraceVar]
[frPrettyLog] :: FrontendResult v x -> [HashMap v x] -> [HashMap String String]
data TraceVar
TraceVar :: Maybe Text -> Text -> TraceVar
[tvFmt] :: TraceVar -> Maybe Text
[tvVar] :: TraceVar -> Text
prettyLog :: (Real t, Show t, PrintfType v, PrintfArg t, ToString a) => [TraceVar] -> [HashMap a t] -> [HashMap String v]
getTraceVarFormat :: Maybe Text -> Text
instance GHC.Show.Show NITTA.Frontends.Common.TraceVar


-- | Much of the work in this module focuses on building waves of process
--   execution. In this case, we call a wave a set of functions that are
--   ready for execution (all input vars are ready to use) and that can be
--   performed independently of each other. Example:
--   
--   Lua code:
--   
--   <pre>
--   function sum(a)
--       local d = a + 1
--       sum(d)
--   end
--   sum(0)
--   </pre>
--   
--   After building DataFlowGraph, we get the following set of functions:
--   
--   <pre>
--   - const(1) = !1#0
--   - loop(0, d^0#0) = a^0#0
--   - a^0#0 + !1#0 = d^0#0
--   </pre>
--   
--   Const and Loop function can be executed at the first wave because all
--   input variables are ready to use. After executing first wave a^0#0 and
--   !1#0 will be ready, so we will be able to execute add function. So the
--   resulting process waves are the following:
--   
--   <pre>
--   [
--       ProcessWave {
--           pwFs = [const(1) = !1#0,loop(0, d^0#0) = a^0#0],
--           pwOut = fromList ["!10"]
--       },
--       ProcessWave {
--           pwFs = [a^0#0 + !1#0 = d^0#0],
--           pwOut = fromList ["d^0#0"]
--       }
--   ]
--   </pre>
module NITTA.Intermediate.Analysis
data ProcessWave v x
ProcessWave :: [F v x] -> Set v -> ProcessWave v x

-- | Functions that can be executed at this wave
[pwFs] :: ProcessWave v x -> [F v x]

-- | Set of output variables related to the functions from this step
[pwOut] :: ProcessWave v x -> Set v

-- | Divide function into execution waves.
buildProcessWaves :: (Var v, Val x) => [v] -> [F v x] -> [ProcessWave v x]

-- | Sort functions in order of execution. Note that some function could be
--   executed in parallel, in this case we save order from the source list.
reorderAlgorithm :: (Var v, Val x) => [F v x] -> [F v x]

-- | Functions can be divided into waves of execution. For each output
--   variable, we define the wave number on which the variable will be
--   defined.
estimateVarWaves :: (Var v, Val x, Num a) => [v] -> [F v x] -> Map v a
instance GHC.Generics.Generic (NITTA.Intermediate.Analysis.ProcessWave v x)
instance GHC.Show.Show v => GHC.Show.Show (NITTA.Intermediate.Analysis.ProcessWave v x)
instance GHC.Generics.Generic (NITTA.Intermediate.Analysis.Builder v x)
instance GHC.Show.Show v => GHC.Show.Show (NITTA.Intermediate.Analysis.Builder v x)


module NITTA.Intermediate.Simulation

-- | Functional algorithm simulation
simulateDataFlowGraph :: (Var v, Val x, WithFunctions g (F v x)) => Int -> CycleCntx v x -> [(v, [x])] -> g -> Cntx v x
simulateAlg :: (Var v, Val x) => Int -> CycleCntx v x -> [(v, [x])] -> [F v x] -> Cntx v x


module NITTA.Frontends.XMILE.Frontend
translateXMILE :: (Hashable v, Suffix v, ToString v, IsString v, Val x, Ord v, Typeable v) => Text -> FrontendResult v x
data FrontendResult v x
FrontendResult :: DataFlowGraph v x -> [TraceVar] -> ([HashMap v x] -> [HashMap String String]) -> FrontendResult v x
[frDataFlow] :: FrontendResult v x -> DataFlowGraph v x
[frTrace] :: FrontendResult v x -> [TraceVar]
[frPrettyLog] :: FrontendResult v x -> [HashMap v x] -> [HashMap String String]
data TraceVar
TraceVar :: Maybe Text -> Text -> TraceVar
[tvFmt] :: TraceVar -> Maybe Text
[tvVar] :: TraceVar -> Text
instance GHC.Show.Show (NITTA.Frontends.XMILE.Frontend.XMILEAlgBuilder v x)


-- | This module analyzes an abstract syntax tree of the Lua language
--   source code, provided by Language.Lua module, and stores it into a
--   NITTA's data flow graph.
--   
--   Supported Lua costructions are:
--   
--   <ul>
--   <li>Simple math operators (addition, subtraction, multiplication and
--   division);</li>
--   <li>Variable assignments;</li>
--   <li>Bitwise left and right shifts;</li>
--   <li>Recursive calls.</li>
--   </ul>
--   
--   The naming of variables in the output dataflow graph:
--   
--   <pre>
--   x^1#2 -- for variables
--   | | |
--   | | +-- value access number (one for each), e.g.
--   | |     x = 1; send(x); reg(x) -- two accesses
--   | |
--   | +---- value assignment number (one for each, optional)
--   |       x = f(1); x = g(2) -- two assignments
--   |
--   +------ original variable name
--   
--   !123#3 -- for constant
--     |  |
--     |  +--- value access number
--     |
--     +------ value: 123
--   
--   _a#4 -- for an unnamed variable (example see below)
--    | |
--    | +--- value access number
--    |
--    +----- char of unnamed variable (a, b..., aa, ab, ...)
--   </pre>
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   void $ mapM print $ functions (frDataFlow $ translateLua $ T.pack $ unlines
--       [ "function f()"
--       , "    local a = 1 + 2 + 3"
--       , "    local b = a + 4 + 5"
--       , "    b = b * 1 + 2"
--       , "    c, d = b / 2"
--       , "    send(b)"
--       , "end"
--       , "f()"
--       ] :: DataFlowGraph String Int)
--   :}
--   const(1) = !1#0 = !1#1
--   const(2) = !2#0 = !2#1 = !2#2
--   !1#0 + !2#0 = _0#a
--   const(3) = !3#0
--   _0#a + !3#0 = a^0#0
--   const(4) = !4#0
--   a^0#0 + !4#0 = _0#b
--   const(5) = !5#0
--   _0#b + !5#0 = b^0#0
--   b^0#0 * !1#1 = _1#b
--   _1#b + !2#1 = b^1#0 = b^1#1
--   !2#2 / b^1#0 = _; !2#2 mod b^1#0 = _
--   send(b^1#1)
--   </pre>
module NITTA.Frontends.Lua
translateLua :: (Var v, Val x) => Text -> FrontendResult v x
data FrontendResult v x
FrontendResult :: DataFlowGraph v x -> [TraceVar] -> ([HashMap v x] -> [HashMap String String]) -> FrontendResult v x
[frDataFlow] :: FrontendResult v x -> DataFlowGraph v x
[frTrace] :: FrontendResult v x -> [TraceVar]
[frPrettyLog] :: FrontendResult v x -> [HashMap v x] -> [HashMap String String]
data TraceVar
TraceVar :: Maybe Text -> Text -> TraceVar
[tvFmt] :: TraceVar -> Maybe Text
[tvVar] :: TraceVar -> Text
data LuaAlgBuilder x
LuaAlgBuilder :: [LuaStatement x] -> HashMap Text LuaValueInstance -> HashMap Text Int -> HashMap LuaValueInstance [Text] -> HashMap Int (Text, Text) -> HashMap Text LuaValueInstance -> [([Text], Maybe Text)] -> LuaAlgBuilder x

-- | A list containing all expressions to be added to the final graph.
[algGraph] :: LuaAlgBuilder x -> [LuaStatement x]

-- | A table that maps a variable name to the most recent corresponding
--   LuaValueInstance.
[algLatestLuaValueInstance] :: LuaAlgBuilder x -> HashMap Text LuaValueInstance

-- | A table needed to generate unique temporary variable names.
[algVarCounters] :: LuaAlgBuilder x -> HashMap Text Int

-- | A table lists all uses of a particular LuaValueInstance.
[algVars] :: LuaAlgBuilder x -> HashMap LuaValueInstance [Text]

-- | Map argument index to the variable name and initial value (in text).
[algStartupArgs] :: LuaAlgBuilder x -> HashMap Int (Text, Text)

-- | A table correlating constant with LuaValueInstance which store this
--   constant.
[algConstants] :: LuaAlgBuilder x -> HashMap Text LuaValueInstance

-- | A list that stores debug information about monitored variables and
--   their display formats.
[algTraceFuncs] :: LuaAlgBuilder x -> [([Text], Maybe Text)]
data LuaStatement x
LuaStatement :: [Text] -> [LuaValueInstance] -> Text -> [x] -> [Int] -> LuaStatement x
[fIn] :: LuaStatement x -> [Text]
[fOut] :: LuaStatement x -> [LuaValueInstance]
[fName] :: LuaStatement x -> Text
[fValues] :: LuaStatement x -> [x]
[fInt] :: LuaStatement x -> [Int]

-- | Stores information about a particular version of a variable. The
--   version of a variable changes after assigning a new value to it.
data LuaValueInstance
LuaValueInstance :: Text -> Int -> Bool -> LuaValueInstance
[lviName] :: LuaValueInstance -> Text
[lviAssignCount] :: LuaValueInstance -> Int
[lviIsConstant] :: LuaValueInstance -> Bool
buildAlg :: (Read x, Show x) => Block -> LuaAlgBuilder x
findStartupFunction :: Block -> (Text, Stat, Stat)
getLuaBlockFromSources :: Text -> Block
processStatement :: (MonadState (LuaAlgBuilder x) m, Read x, Show x) => Text -> Stat -> m ()
instance GHC.Classes.Eq NITTA.Frontends.Lua.LuaValueInstance
instance GHC.Show.Show NITTA.Frontends.Lua.LuaValueInstance
instance GHC.Classes.Eq x => GHC.Classes.Eq (NITTA.Frontends.Lua.LuaStatement x)
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Frontends.Lua.LuaStatement x)
instance GHC.Show.Show x => GHC.Show.Show (NITTA.Frontends.Lua.LuaAlgBuilder x)
instance Data.Hashable.Class.Hashable NITTA.Frontends.Lua.LuaValueInstance


module NITTA.Frontends
data FrontendType
Lua :: FrontendType
XMILE :: FrontendType
data FrontendResult v x
FrontendResult :: DataFlowGraph v x -> [TraceVar] -> ([HashMap v x] -> [HashMap String String]) -> FrontendResult v x
[frDataFlow] :: FrontendResult v x -> DataFlowGraph v x
[frTrace] :: FrontendResult v x -> [TraceVar]
[frPrettyLog] :: FrontendResult v x -> [HashMap v x] -> [HashMap String String]
data TraceVar
TraceVar :: Maybe Text -> Text -> TraceVar
[tvFmt] :: TraceVar -> Maybe Text
[tvVar] :: TraceVar -> Text
prettyLog :: (Real t, Show t, PrintfType v, PrintfArg t, ToString a) => [TraceVar] -> [HashMap a t] -> [HashMap String v]
getTraceVarFormat :: Maybe Text -> Text
identifyFrontendType :: FilePath -> Maybe FrontendType -> FrontendType
translate :: (IsString v, ToString v, Suffix v, Hashable v, Val x, Typeable v, Ord v) => FrontendType -> Text -> FrontendResult v x
instance Data.Data.Data NITTA.Frontends.FrontendType
instance GHC.Show.Show NITTA.Frontends.FrontendType


-- | A multilevel process is an object with a complex internal structure.
--   Process description should contain every step (including start and
--   finish time), and relations between them (Vertical or sequence). It is
--   possible to define process manually, but, in practice, is preferred to
--   use <a>State</a> based builder from that module.
--   
--   It also agreed to the process inspection.
module NITTA.Utils.ProcessDescription

-- | Execute process builder and return list of new step UID and new
--   process description. The initial process state is getting from the PU
--   by the <a>process</a> function.
runSchedule :: ProcessorUnit u v x t => u -> State (Schedule u v x t) a -> (a, Process t (StepInfo v x t))

-- | Execute process builder and return new process description. The
--   initial process state is getting from the PU by the <a>process</a>
--   function.
execSchedule :: ProcessorUnit u v x t => u -> State (Schedule u v x t) a -> Process t (StepInfo v x t)

-- | Execute process builder and return new process description. The
--   initial process state is passed explicetly.
--   
--   Why can not we get a process here? In the case of Bus Network, it also
--   fetches processes from underlying units.
execScheduleWithProcess :: pu -> Process t (StepInfo v x t) -> State (Schedule pu v x t) a -> Process t (StepInfo v x t)

-- | Add process step with passed the time and info.
scheduleStep :: MonadState (Schedule pu v x t) m => Interval t -> StepInfo v x t -> m [ProcessStepID]

-- | Add to the process description information about endpoint behaviour,
--   and it's low-level implementation (on instruction level). Vertical
--   relations connect endpoint level and instruction level steps.
scheduleEndpoint :: forall {m} {pu} {v} {x} {t}. MonadState (Schedule pu v x t) m => EndpointSt v (Interval t) -> m [ProcessStepID] -> m [ProcessStepID]
scheduleEndpoint_ :: forall {f} {pu} {v} {x} {t}. MonadState (Schedule pu v x t) f => EndpointSt v (Interval t) -> f [ProcessStepID] -> f ()
scheduleFunctionBind :: (MonadState (Schedule pu v x t) m, Show a) => a -> m [ProcessStepID]
scheduleFunctionRevoke :: (MonadState (Schedule pu v x t) m, Show a) => a -> m [ProcessStepID]

-- | Add to the process description information about function evaluation.
scheduleFunction :: MonadState (Schedule pu v x t) m => Interval t -> F v x -> m [ProcessStepID]

-- | Schedule function and establish vertical relations between bind step,
--   function step, and all related endpoints.
scheduleFunctionFinish :: (Ord v, Typeable v, IsString v, ToString v, Suffix v, Hashable v) => [ProcessStepID] -> F v x -> Interval t -> StateT (Schedule pu v x t) Identity [ProcessStepID]
scheduleFunctionFinish_ :: (Ord v, Typeable v, IsString v, ToString v, Suffix v, Hashable v) => [ProcessStepID] -> F v x -> Interval t -> StateT (Schedule pu v x t) Identity ()
scheduleRefactoring :: (MonadState (Schedule pu v x t) m, Typeable ref, Show ref, Eq ref) => Interval t -> ref -> m [ProcessStepID]

-- | Add to the process description information about instruction
--   evaluation. Unsafe means: without instruction collision check and
--   nextTick consistency.
scheduleInstructionUnsafe :: (MonadState (Schedule pu v x t) m, Show (Instruction pu), Typeable pu, Num t) => Interval t -> Instruction pu -> m [ProcessStepID]
scheduleInstructionUnsafe_ :: forall {f} {pu} {v} {x} {t}. (MonadState (Schedule pu v x t) f, Show (Instruction pu), Typeable pu, Num t) => Interval t -> Instruction pu -> f ()

-- | Add to the process description information about nested step.
scheduleNestedStep :: forall {m} {pu} {v} {x} {t} {tag}. (MonadState (Schedule pu v x t) m, UnitTag tag) => tag -> Step t (StepInfo v x t) -> m ProcessStepID

-- | Add to the process description information about vertical relations,
--   which are defined by the Cartesian product of high and low lists.
establishVerticalRelations :: forall {m} {pu} {v} {x} {t}. MonadState (Schedule pu v x t) m => [ProcessStepID] -> [ProcessStepID] -> m ()

-- | Add to the process description information about horizontal relations
--   (inside level), which are defined by the Cartesian product of high and
--   low lists.
establishHorizontalRelations :: forall {m} {pu} {v} {x} {t}. MonadState (Schedule pu v x t) m => [ProcessStepID] -> [ProcessStepID] -> m ()

-- | Get a current slice of the computational process.
getProcessSlice :: State (Schedule pu v x t) (Process t (StepInfo v x t))
relatedEndpoints :: Ord a => Process t (StepInfo a x t) -> Set a -> [Step t (StepInfo a x t)]

-- | Helper for instruction extraction from a rigid type variable.
castInstruction :: (Typeable a, Typeable pu) => pu -> a -> Maybe (Instruction pu)
scheduleAllocation :: (MonadState (Schedule pu v x t) m, Typeable a, Show a, Eq a) => a -> m [ProcessStepID]
instance NITTA.Model.ProcessorUnits.Types.NextTick (NITTA.Utils.ProcessDescription.Schedule pu v x t) t


module NITTA.Utils
doc2text :: Verilog -> Text
type Verilog = Doc ()
shiftI :: (Num a, Ord a) => a -> Interval a -> Interval a
bool2verilog :: Bool -> Text
values2dump :: (Foldable t, Show a) => t a -> [Char]
hdlValDump :: Val p => p -> Text
toModuleName :: [Char] -> [Char]
endpointAt :: (Ord a, Show a, ToString v) => a -> Process a (StepInfo v x t) -> Maybe (EndpointRole v)
getEndpoint :: Step t (StepInfo v x t) -> Maybe (EndpointRole v)
getInstruction :: Step t (StepInfo v x t) -> Maybe (StepInfo v x t)
getEndpoints :: Ord b => Process b (StepInfo v x t) -> [EndpointRole v]
transferred :: ProcessorUnit u a1 x t => u -> Set a1
inputsPushedAt :: (Ord a, Ord a, Function f a) => Process a (StepInfo a x t2) -> f -> a
stepsInterval :: Ord a => [Step a i] -> Interval a
relatedEndpoints :: Ord a => Process t1 (StepInfo a x t2) -> Set a -> [Step t1 (StepInfo a x t2)]
isIntermediate :: Step t (StepInfo v x t) -> Bool
getIntermediate :: Step t (StepInfo v x t) -> Maybe (F v x)
getIntermediates :: Ord b => Process b (StepInfo v x t) -> [F v x]
isInstruction :: Step t (StepInfo v x t) -> Bool
getToml :: Text -> Table
getFromToml :: (FromJSON a, ToJSON a) => HashMap Text a -> a
getFromTomlSection :: (FromJSON a, ToJSON a) => Text -> HashMap Text a -> a


module NITTA.Project.Types

-- | Target project for different purpose (testing, target system, etc).
--   Should be writable to disk.
data Project m v x
Project :: Text -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> m -> UnitEnv m -> Cntx v x -> [FilePath] -> Project m v x

-- | target project name
[pName] :: Project m v x -> Text

-- | IP-core library path
[pLibPath] :: Project m v x -> FilePath

-- | output path for target project
[pTargetProjectPath] :: Project m v x -> FilePath

-- | absolute output path for target project
[pAbsTargetProjectPath] :: Project m v x -> FilePath

-- | relative to the project path output path for NITTA processor inside
--   target project
[pInProjectNittaPath] :: Project m v x -> FilePath

-- | absolute output path for NITTA processor inside target project
[pAbsNittaPath] :: Project m v x -> FilePath

-- | <tt>mUnit</tt> model (a mUnit unit for testbench or network for
--   complete NITTA mUnit)
[pUnit] :: Project m v x -> m
[pUnitEnv] :: Project m v x -> UnitEnv m

-- | testbench context with input values
[pTestCntx] :: Project m v x -> Cntx v x

-- | Target platform templates
[pTemplates] :: Project m v x -> [FilePath]
defProjectTemplates :: [FilePath]

-- | Type class for target components. Target -- a target system project or
--   a testbench.
class TargetSystemComponent pu

-- | Name of the structural hardware module or Verilog module name (network
--   or process unit)
moduleName :: TargetSystemComponent pu => Text -> pu -> Text

-- | Software and other specification which depends on application
--   algorithm
software :: TargetSystemComponent pu => Text -> pu -> Implementation

-- | Hardware which depends on microarchitecture description and requires
--   synthesis.
hardware :: TargetSystemComponent pu => Text -> pu -> Implementation

-- | Generate code for making an instance of the hardware module
hardwareInstance :: TargetSystemComponent pu => Text -> pu -> UnitEnv pu -> Verilog

-- | Element of target system implementation
data Implementation

-- | Immediate implementation in the from of Ginger template
--   (<tt>nitta.paths.nest</tt> + <tt>projectContext</tt>)
Immediate :: FilePath -> Text -> Implementation
[impFileName] :: Implementation -> FilePath
[impText] :: Implementation -> Text

-- | Fetch implementation from library
FromLibrary :: FilePath -> Implementation
[impFileName] :: Implementation -> FilePath

-- | Aggregation of many implementation parts in separate paths
Aggregate :: Maybe FilePath -> [Implementation] -> Implementation
[impPath] :: Implementation -> Maybe FilePath
[subComponents] :: Implementation -> [Implementation]

-- | Nothing
Empty :: Implementation

-- | Resolve uEnv element to verilog source code. E.g. <tt>dataIn</tt> into
--   <tt>data_bus</tt>, <tt>dataOut</tt> into <tt>accum_data_out</tt>.
data UnitEnv m
UnitEnv :: Text -> Text -> Text -> Text -> Text -> Maybe (Ports m) -> Maybe (IOPorts m) -> Maybe (Text, Text) -> UnitEnv m

-- | clock signal
[sigClk] :: UnitEnv m -> Text

-- | reset signal
[sigRst] :: UnitEnv m -> Text

-- | posedge on computation cycle begin
[sigCycleBegin] :: UnitEnv m -> Text

-- | positive on computation cycle
[sigInCycle] :: UnitEnv m -> Text

-- | posedge on computation cycle end
[sigCycleEnd] :: UnitEnv m -> Text
[ctrlPorts] :: UnitEnv m -> Maybe (Ports m)
[ioPorts] :: UnitEnv m -> Maybe (IOPorts m)
[valueIn, valueOut] :: UnitEnv m -> Maybe (Text, Text)
envInputPorts :: IOConnected pu => UnitEnv pu -> Set InputPortTag
envOutputPorts :: IOConnected pu => UnitEnv pu -> Set OutputPortTag
envInOutPorts :: IOConnected pu => UnitEnv pu -> Set InoutPortTag
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Project.Types.Project m v x) x
instance Data.Default.Class.Default (NITTA.Project.Types.UnitEnv m)


module NITTA.Project.TestBench

-- | Type class for all testable parts of a target system.
class Testable m v x | m -> v x
testBenchImplementation :: Testable m v x => Project m v x -> Implementation

-- | Processor units with input/output ports should be tested by generation
--   external input ports signals and checking output port signals.
class IOTestBench pu v x | pu -> v x
testEnvironmentInitFlag :: IOTestBench pu v x => Text -> pu -> Maybe Text
testEnvironment :: IOTestBench pu v x => Text -> pu -> UnitEnv pu -> TestEnvironment v x -> Maybe Verilog

-- | Information required for testbench generation.
data TestEnvironment v x
TestEnvironment :: Cntx v x -> Int -> TestEnvironment v x

-- | expected data
[teCntx] :: TestEnvironment v x -> Cntx v x

-- | duration of computational process
[teComputationDuration] :: TestEnvironment v x -> Int
data TestbenchReport v x
TestbenchReport :: Bool -> FilePath -> [FilePath] -> [Text] -> [Text] -> Text -> Text -> [HashMap v x] -> [HashMap v x] -> TestbenchReport v x
[tbStatus] :: TestbenchReport v x -> Bool
[tbPath] :: TestbenchReport v x -> FilePath
[tbFiles] :: TestbenchReport v x -> [FilePath]
[tbFunctions] :: TestbenchReport v x -> [Text]
[tbSynthesisSteps] :: TestbenchReport v x -> [Text]
[tbCompilerDump] :: TestbenchReport v x -> Text
[tbSimulationDump] :: TestbenchReport v x -> Text
[tbFunctionalSimulationLog] :: TestbenchReport v x -> [HashMap v x]
[tbLogicalSimulationLog] :: TestbenchReport v x -> [HashMap v x]

-- | Get name of testbench top module.
testBenchTopModuleName :: (TargetSystemComponent m, Testable m v x) => Project m v x -> FilePath

-- | Generate list of project verilog files (including testbench).
verilogProjectFiles :: (TargetSystemComponent m, Testable m v x) => Project m v x -> [FilePath]

-- | Data Type for SnippetTestBench function
data SnippetTestBenchConf m
SnippetTestBenchConf :: [Text] -> Ports m -> (Microcode m -> Text) -> SnippetTestBenchConf m
[tbcSignals] :: SnippetTestBenchConf m -> [Text]
[tbcPorts] :: SnippetTestBenchConf m -> Ports m
[tbcMC2verilogLiteral] :: SnippetTestBenchConf m -> Microcode m -> Text

-- | Function for testBench PU test
snippetTestBench :: forall m v x t. (WithFunctions m (F v x), ProcessorUnit m v x t, TargetSystemComponent m, UnambiguouslyDecode m, Typeable m, Show (Instruction m), Default (Microcode m)) => Project m v x -> SnippetTestBenchConf m -> Text
instance GHC.Generics.Generic (NITTA.Project.TestBench.TestbenchReport v x)
instance (Data.String.ToString.ToString v, GHC.Show.Show x) => GHC.Show.Show (NITTA.Project.TestBench.TestbenchReport v x)


module NITTA.Model.Networks.Types

-- | Existential container for a processor unit .
data PU v x t
[PU] :: PUClasses pu v x t => pu -> Changeset v -> UnitEnv pu -> PU v x t
unitType :: PU v x t -> TypeRep
type PUClasses pu v x t = (ByTime pu t, Connected pu, IOConnected pu, EndpointProblem pu v t, BreakLoopProblem pu v x, ConstantFoldingProblem pu v x, OptimizeAccumProblem pu v x, ResolveDeadlockProblem pu v x, ProcessorUnit pu v x t, Show (Instruction pu), Typeable pu, UnambiguouslyDecode pu, TargetSystemComponent pu, Controllable pu, IOTestBench pu v x, Locks pu v, Typeable pu)
data IOSynchronization

-- | IO cycle synchronously to process cycle
Sync :: IOSynchronization

-- | if IO cycle lag behiend - ignore them
ASync :: IOSynchronization

-- | defined by onboard signal (sync - false, async - true)
OnBoard :: IOSynchronization

-- | PU and some additional information required for allocation on
--   BusNetwork
data PUPrototype tag v x t
[PUPrototype] :: (UnitTag tag, PUClasses pu v x t) => tag -> pu -> IOPorts pu -> PUPrototype tag v x t
puInputPorts :: PU v x t -> Set InputPortTag
puOutputPorts :: PU v x t -> Set OutputPortTag
puInOutPorts :: PU v x t -> Set InoutPortTag
instance GHC.Generics.Generic NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Read.Read NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Show.Show NITTA.Model.Networks.Types.IOSynchronization
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Networks.Types.IOSynchronization
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Networks.Types.IOSynchronization
instance GHC.Classes.Ord v => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.Networks.Types.PU v x t) v t
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.Networks.Types.PU v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.Networks.Types.PU v x t) v x t
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.Changeset v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.I v, NITTA.Intermediate.Types.I v)
instance GHC.Classes.Ord v => NITTA.Intermediate.Types.Patch (NITTA.Model.Networks.Types.PU v x t) (NITTA.Intermediate.Types.O v, NITTA.Intermediate.Types.O v)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.Networks.Types.PU v x t) v
instance NITTA.Project.Types.TargetSystemComponent (NITTA.Model.Networks.Types.PU v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.Networks.Types.PU v x t) v x


module NITTA.Project.Context

-- | projectContext - used for template generation
projectContext :: (TargetSystemComponent m, Testable m v x) => Project m v x -> GingerContext p (Writer Text) Text

-- | projectContext - used for Implementation generation
implementationContext :: (TargetSystemComponent m, Testable m v x, ToGVal (Run p (Writer Text) Text) a) => Project m v x -> a -> GingerContext p (Writer Text) Text


module NITTA.Project.Template
writeRenderedTemplates :: (TargetSystemComponent m, Testable m v x) => Project m v x -> IO ()

-- | collectNittaPath - read nittaPath from all provided target templates
--   and return it if all of them are the same.
collectNittaPath :: [FilePath] -> IO (Either Text FilePath)

-- | projectContext - used for template generation
projectContext :: (TargetSystemComponent m, Testable m v x) => Project m v x -> GingerContext p (Writer Text) Text
instance GHC.Show.Show NITTA.Project.Template.TemplateConf
instance GHC.Generics.Generic NITTA.Project.Template.TemplateConf
instance GHC.Show.Show NITTA.Project.Template.Conf
instance Data.Default.Class.Default NITTA.Project.Template.TemplateConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Project.Template.TemplateConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Project.Template.TemplateConf
instance Data.Hashable.Class.Hashable k => Data.Default.Class.Default (Data.HashMap.Internal.HashMap k v)


module NITTA.Project

-- | Write project with all available parts.
writeProject :: (TargetSystemComponent m, Testable m v x) => Project m v x -> IO ()
runTestbench :: (WithFunctions u a, ProcessorUnit u v x t, Hashable v, IsString v, DefaultX u p, Val p, Show a, Read x, TargetSystemComponent u, Testable u v x) => Project u v x -> IO (TestbenchReport v x)


module NITTA.Model.ProcessorUnits.Shift
data Shift v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
shift :: Default t => Bool -> Shift v x t
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Shift.Mode
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Shift.Mode
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v
instance Data.Default.Class.Default t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x t
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Shift.Shift v x t))
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Intermediate.Value.Val x => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Shift.Shift v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Shift.Shift v x t) v x


-- | <h1>Processor unit</h1>
--   
--   A processor unit (PU) can be used for:
--   
--   <ul>
--   <li>data storage and processing;</li>
--   <li>interaction with the periphery (IO);</li>
--   <li>control of a NITTA processor (special case).</li>
--   </ul>
--   
--   There are characterized by complicated behavior with:
--   
--   <ul>
--   <li>multifunctionality;</li>
--   <li>internal parallelism;</li>
--   <li>superscalar;</li>
--   <li>pipelining;</li>
--   <li>availability of internal resources.</li>
--   </ul>
--   
--   The multiplier PU is one of the simplest processors because it
--   realizes only one function with sequence evaluation (<a>Multiply</a>).
--   Processor behavior in a specific application is determined by the
--   applied algorithm (<a>DataFlow</a>).
--   
--   Any PU may include three components:
--   
--   <ul>
--   <li>hardware - set of prepared or automatically generated hardware
--   descriptions (<tt>/hdl/multiplier</tt>);</li>
--   <li>software - set of binary files that determine:<ul><li>initial
--   state and setting ;</li><li>a control program;</li></ul></li>
--   <li>PU model - CAD component that implements PU support (hardware and
--   software generation, instance generation, computation process
--   scheduling, testing environment, etc.).</li>
--   </ul>
--   
--   All three components are hardly related to each other and needed to
--   comply with each other strictly. For a deeper understanding, a PU
--   developer should understand all of its components. The multiplier
--   model will be described above.
--   
--   <h2>Processor unit model</h2>
--   
--   A model purpose is "teaching" CAD how to work with the PU:
--   
--   <ul>
--   <li>Which functions can be evaluated by PU? (see
--   <a>ProcessorUnit</a>)?</li>
--   <li>How to control PU for evaluating specific functions (see
--   <a>ProcessorUnit</a>, <a>Controllable</a>)?</li>
--   <li>How to translating instructions to microcode (see
--   <a>UnambiguouslyDecode</a>)?</li>
--   <li>What are the options of PU synthesis decision available? (see
--   <a>ProcessorUnit</a>, <a>EndpointDT</a>):<ul><li>push variable to the
--   PU (<a>Target</a>);</li><li>pull at least one variable from the PU
--   (<a>Source</a>).</li></ul></li>
--   </ul>
--   
--   The basis of a PU model is a data structure that represents:
--   
--   <ul>
--   <li>PU state during computation process scheduling;</li>
--   <li>process description (full or fragment), which can be translated to
--   microcode.</li>
--   </ul>
--   
--   Exactly around this data structure, all algorithmic part of the PU
--   model is developed. The types of the following variables parametrize
--   the data structure:
--   
--   <ul>
--   <li><tt>v</tt> - variable id (usually <a>String</a>);</li>
--   <li><tt>x</tt> - a type of processed value (see <a>Val</a>);</li>
--   <li><tt>t</tt> - time moment id (usually <a>Int</a>).</li>
--   </ul>
--   
--   <h1>Multiplier processor unit</h1>
--   
--   The multiplier processor unit can evaluate the following function
--   type:
--   
--   <ul>
--   <li><a>Multiply</a>.</li>
--   </ul>
--   
--   Only one function can be processed in one moment, and its execution
--   cannot be interrupted.
--   
--   This module should be considered as a tutorial for the development of
--   other models of processor units. Its source code is written almost in
--   literature style, so we recommend to continue reading within the
--   source code.
--   
--   <h2>Interaction with multiplier processor unit</h2>
--   
--   We will consider the example of the computation process scheduling for
--   one function. To do this, we need to start GHCi interpreter by
--   executing `stack repl` command from the project directory. After that:
--   
--   <pre>
--   &gt; :l NITTA.Model.ProcessorUnits.Multiplier
--   [ 1 of 30] Compiling NITTA.Intermediate.Value ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Value.hs, interpreted )
--   [ 2 of 30] Compiling NITTA.Intermediate.Variable ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Variable.hs, interpreted )
--   [ 3 of 30] Compiling NITTA.Intermediate.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Types.hs, interpreted )
--   [ 4 of 30] Compiling NITTA.Model.Problems.Binding ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsBinding.hs, interpreted )
--   [ 5 of 30] Compiling NITTA.Model.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Types.hs, interpreted )
--   [ 6 of 30] Compiling NITTA.Model.Problems.Endpoint ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsEndpoint.hs, interpreted )
--   [ 7 of 30] Compiling NITTA.Model.Problems.Dataflow ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsDataflow.hs, interpreted )
--   [ 8 of 30] Compiling NITTA.Project.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Types.hs, interpreted )
--   [ 9 of 30] Compiling NITTA.Utils.Base ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/Base.hs, interpreted )
--   [10 of 30] Compiling NITTA.Intermediate.Functions.Accum ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediateFunctionsAccum.hs, interpreted )
--   [11 of 30] Compiling NITTA.Intermediate.Functions ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Functions.hs, interpreted )
--   [12 of 30] Compiling NITTA.Model.Problems.Refactor ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsRefactor.hs, interpreted )
--   [13 of 30] Compiling NITTA.Model.Problems.Whole ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsWhole.hs, interpreted )
--   [14 of 30] Compiling NITTA.Model.Problems ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Problems.hs, interpreted )
--   [15 of 30] Compiling NITTA.Utils.CodeFormat ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/CodeFormat.hs, interpreted )
--   [16 of 30] Compiling NITTA.Model.ProcessorUnits.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsTypes.hs, interpreted )
--   [17 of 30] Compiling NITTA.Utils      ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils.hs, interpreted )
--   [18 of 30] Compiling NITTA.Project.VerilogSnippets ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Snippets.hs, interpreted )
--   [19 of 30] Compiling NITTA.Project.Implementation ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Implementation.hs, interpreted )
--   [20 of 30] Compiling NITTA.Project.Parts.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsUtils.hs, interpreted )
--   [21 of 30] Compiling NITTA.Project.TestBench ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTestBench.hs, interpreted )
--   [22 of 30] Compiling NITTA.Project.Parts.TargetSystem ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTargetSystem.hs, interpreted )
--   [23 of 30] Compiling NITTA.Project.Parts.Icarus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsIcarus.hs, interpreted )
--   [24 of 30] Compiling NITTA.Model.Networks.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksTypes.hs, interpreted )
--   [25 of 30] Compiling NITTA.Utils.ProcessDescription ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/ProcessDescription.hs, interpreted )
--   [26 of 30] Compiling NITTA.Model.Networks.Bus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksBus.hs, interpreted )
--   [27 of 30] Compiling NITTA.Project.Parts.Quartus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsQuartus.hs, interpreted )
--   [28 of 30] Compiling NITTA.Project.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Utils.hs, interpreted )
--   [29 of 30] Compiling NITTA.Project    ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject.hs, interpreted )
--   [30 of 30] Compiling NITTA.Model.ProcessorUnits.Multiplier ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsMultiplier.hs, interpreted )
--   Ok, 30 modules loaded.
--   &gt; :module +NITTA.Model.ProcessorUnits.Types NITTA.Intermediate.Functions Numeric.Interval.NonEmpty Data.Set Prettyprinter.Render.Text
--   &gt; :set prompt "ESC[34m&gt; ESC[m"
--   </pre>
--   
--   Now create the function and multiplier model initial state.
--   Unfortunately, it is not enough information for GHC deduction of its
--   type, so let's define its implicitly.
--   
--   <pre>
--   &gt;&gt;&gt; :module +Prettyprinter.Render.Text
--   
--   &gt;&gt;&gt; let f = F.multiply "a" "b" ["c", "d"] :: F String Int
--   
--   &gt;&gt;&gt; f
--   a * b = c = d
--   
--   &gt;&gt;&gt; let st0 = multiplier True :: Multiplier String Int Int
--   
--   &gt;&gt;&gt; putDoc $ pretty st0
--   Multiplier:
--       remain: []
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--           relations:
--           nextTick: 0
--           nextUid: 0
--   
--   &gt;&gt;&gt; endpointOptions st0
--   []
--   </pre>
--   
--   Bind a function to the multiplier unit. This operation could be
--   executed at any time of working with a model, including when a
--   computation process is fully scheduled (new work can be added). The
--   main rules are: 1) if work is fully scheduled, then it is necessary to
--   perform it, and any part of it cannot be "lost" inside the model; 2)
--   if a unit has its internal resources, there should be enough to finish
--   schedule, even it is inefficient.
--   
--   <pre>
--   &gt;&gt;&gt; let Right st1 = tryBind f st0
--   
--   &gt;&gt;&gt; putDoc $ pretty st1
--   Multiplier:
--       remain: [a * b = c = d]
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--           relations:
--           nextTick: 0
--           nextUid: 0
--   
--   &gt;&gt;&gt; endpointOptions st1
--   [?Target a@(0..INF /P 1..INF),?Target b@(0..INF /P 1..INF)]
--   </pre>
--   
--   As we can see, after binding, we have two different options of
--   computational process scheduling that match different argument loading
--   sequences: <tt>a</tt> or <tt>b</tt>. We can see that they are similar
--   from an execution sequence point of view: loading can be started from
--   0 tick or after an arbitrary delay; for loading of one argument needed
--   only one tick, but it can continue for an arbitrary time. Choose the
--   variant.
--   
--   <pre>
--   &gt;&gt;&gt; let st2 = endpointDecision st1 $ EndpointSt (Target "a") (0...2)
--   
--   &gt;&gt;&gt; putDoc $ pretty st2
--   Multiplier:
--       remain: []
--       targets: ["b"]
--       sources: ["c","d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
--           relations:
--               0) Vertical {vUp = 0, vDown = 1}
--           nextTick: 3
--           nextUid: 2
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st2
--   ?Target b@(3..INF /P 1..INF)
--   
--   &gt;&gt;&gt; let st3 = endpointDecision st2 $ EndpointSt (Target "b") (3...3)
--   
--   &gt;&gt;&gt; putDoc $ pretty st3
--   Multiplier:
--       remain: []
--       targets: []
--       sources: ["c","d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
--           relations:
--               0) Vertical {vUp = 2, vDown = 3}
--               1) Vertical {vUp = 0, vDown = 1}
--           nextTick: 4
--           nextUid: 4
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st3
--   ?Source c,d@(6..INF /P 1..INF)
--   </pre>
--   
--   After loading both arguments, we can see that the next option is
--   unloading <tt>c</tt> and <tt>d</tt> variables. Note, these variables
--   can be unloaded either concurrently or sequentially (for details, see
--   how the multiplier works inside). Consider the second option:
--   
--   <pre>
--   &gt;&gt;&gt; let st4 = endpointDecision st3 $ EndpointSt (Source $ S.fromList ["c"]) (6...6)
--   
--   &gt;&gt;&gt; putDoc $ pretty st4
--   Multiplier:
--       remain: []
--       targets: []
--       sources: ["d"]
--       currentWork: Just a * b = c = d
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
--               4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
--               5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
--           relations:
--               0) Vertical {vUp = 4, vDown = 5}
--               1) Vertical {vUp = 2, vDown = 3}
--               2) Vertical {vUp = 0, vDown = 1}
--           nextTick: 7
--           nextUid: 6
--   
--   &gt;&gt;&gt; mapM_ print $ endpointOptions st4
--   ?Source d@(7..INF /P 1..INF)
--   
--   &gt;&gt;&gt; let st5 = endpointDecision st4 $ EndpointSt (Source $ S.fromList ["d"]) (7...7)
--   
--   &gt;&gt;&gt; putDoc $ pretty st5
--   Multiplier:
--       remain: []
--       targets: []
--       sources: []
--       currentWork: Nothing
--       isMocked: True
--       Process:
--           steps:
--               0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
--               1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
--               2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
--               3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
--               4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
--               5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
--               6) Step {pID = 6, pInterval = 7 ... 7, pDesc = Endpoint: Source d}
--               7) Step {pID = 7, pInterval = 7 ... 7, pDesc = Instruction: Out}
--               8) Step {pID = 8, pInterval = 0 ... 7, pDesc = Intermediate: a * b = c = d}
--           relations:
--               0) Vertical {vUp = 8, vDown = 6}
--               1) Vertical {vUp = 8, vDown = 4}
--               2) Vertical {vUp = 8, vDown = 2}
--               3) Vertical {vUp = 8, vDown = 0}
--               4) Vertical {vUp = 6, vDown = 7}
--               5) Vertical {vUp = 4, vDown = 5}
--               6) Vertical {vUp = 2, vDown = 3}
--               7) Vertical {vUp = 0, vDown = 1}
--           nextTick: 8
--           nextUid: 9
--   
--   &gt;&gt;&gt; endpointOptions st5
--   []
--   </pre>
--   
--   All options of computing process scheduling are run out. All bound
--   functions are planned. Further microcode can be generated, which can
--   be organizing the described computational process on the multiplier.
module NITTA.Model.ProcessorUnits.Multiplier

-- | Multiplier PU model constructor. Argument defines the computation
--   unit's internal organization: using multiplier IP kernel (False) or
--   mock (True). For more information, look hardware function in
--   <a>TargetSystemComponent</a> class.
multiplier :: Default t => Bool -> Multiplier v x t

-- | It is a PU model state representation, which describes each state of
--   synthesis model for that PU.
data Multiplier v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x t
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Multiplier.Multiplier v x t) v x


module NITTA.Model.ProcessorUnits.IO.SimpleIO
class Typeable i => SimpleIOInterface i
data SimpleIO i v x t
SimpleIO :: Int -> Maybe Int -> [Q v x] -> Int -> Bool -> [Q v x] -> Int -> Process t (StepInfo v x t) -> SimpleIO i v x t
[$sel:bounceFilter:SimpleIO] :: SimpleIO i v x t -> Int

-- | if <a>Nothing</a> then size should defined by algorithm
[$sel:bufferSize:SimpleIO] :: SimpleIO i v x t -> Maybe Int
[$sel:receiveQueue:SimpleIO] :: SimpleIO i v x t -> [Q v x]
[$sel:receiveN:SimpleIO] :: SimpleIO i v x t -> Int

-- | set if send buffer overlap receive buffer
[$sel:isReceiveOver:SimpleIO] :: SimpleIO i v x t -> Bool
[$sel:sendQueue:SimpleIO] :: SimpleIO i v x t -> [Q v x]
[$sel:sendN:SimpleIO] :: SimpleIO i v x t -> Int
[$sel:process_:SimpleIO] :: SimpleIO i v x t -> Process t (StepInfo v x t)

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
protocolDescription :: forall i v x t. (VarValTime v x t, SimpleIOInterface i, ToJSON v) => Text -> SimpleIO i v x t -> Text -> Implementation
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance GHC.Generics.Generic (NITTA.Model.ProcessorUnits.IO.SimpleIO.ProtocolDescription v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.ProcessorUnits.IO.SimpleIO.ProtocolDescription v)
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x t
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v x
instance (NITTA.Model.Time.VarValTime v x t, NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface i) => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIO i v x t) v
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => GHC.Show.Show (NITTA.Model.ProcessorUnits.IO.SimpleIO.Q v x)


module NITTA.Model.ProcessorUnits.IO.SPI
type SPI v x t = SimpleIO SPIinterface v x t
anySPI :: Time t => Int -> Maybe Int -> SPI v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
spiMasterPorts :: Text -> IOPorts (SPI v x t)
spiSlavePorts :: Text -> IOPorts (SPI v x t)
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t))
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance (Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.IO.SPI.SPI v x t) v x
instance NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface NITTA.Model.ProcessorUnits.IO.SPI.SPIinterface


module NITTA.Model.ProcessorUnits.IO.I2C
type I2C v x t = SimpleIO I2Cinterface v x t
i2cUnit :: Time t => Int -> I2C v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t))
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t)
instance (Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.IO.I2C.I2C v x t)
instance NITTA.Model.ProcessorUnits.IO.SimpleIO.SimpleIOInterface NITTA.Model.ProcessorUnits.IO.I2C.I2Cinterface


module NITTA.Model.ProcessorUnits.Fram
data Fram v x t
Fram :: Array Int (Cell v x t) -> [(Buffer v x, Job v x t)] -> Process t (StepInfo v x t) -> Fram v x t

-- | memory cell array
[$sel:memory:Fram] :: Fram v x t -> Array Int (Cell v x t)

-- | register queue
[$sel:remainBuffers:Fram] :: Fram v x t -> [(Buffer v x, Job v x t)]
[$sel:process_:Fram] :: Fram v x t -> Process t (StepInfo v x t)

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
framWithSize :: (Default x, Default t) => Int -> Fram v x t
instance GHC.Classes.Eq t => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Fram.Job v x t)
instance GHC.Show.Show t => GHC.Show.Show (NITTA.Model.ProcessorUnits.Fram.Job v x t)
instance (GHC.Classes.Eq v, GHC.Classes.Eq t) => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Fram.CellState v x t)
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance (Data.Default.Class.Default t, Data.Default.Class.Default x) => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Fram.Fram v x t) x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Fram.Fram v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Intermediate.Variable.Variables (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x t
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Fram.Fram v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Fram.Fram v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Fram.Fram v x t) v x
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Fram.Cell v x t) (NITTA.Intermediate.Types.F v x)
instance Data.Default.Class.Default x => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Fram.Cell v x t)
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Fram.CellState v x t)


module NITTA.Model.ProcessorUnits.Divider
data Divider v x t
Divider :: [Job v x t] -> [F v x] -> Process t (StepInfo v x t) -> t -> Bool -> Divider v x t
[$sel:jobs:Divider] :: Divider v x t -> [Job v x t]
[$sel:remains:Divider] :: Divider v x t -> [F v x]
[$sel:process_:Divider] :: Divider v x t -> Process t (StepInfo v x t)
[$sel:pipeline:Divider] :: Divider v x t -> t
[$sel:mock:Divider] :: Divider v x t -> Bool
divider :: Default t => t -> Bool -> Divider v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Divider.InputDesc
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Divider.InputDesc
instance GHC.Classes.Eq NITTA.Model.ProcessorUnits.Divider.OutputDesc
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Divider.OutputDesc
instance (GHC.Show.Show v, GHC.Show.Show t) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Divider.Job v x t)
instance (GHC.Classes.Eq v, GHC.Classes.Eq t) => GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Divider.Job v x t)
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance (GHC.Show.Show v, GHC.Show.Show t) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Divider.Divider v x t) x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Divider.Divider v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x t
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Divider.Divider v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance (NITTA.Intermediate.Value.Val x, GHC.Show.Show t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Divider.Divider v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Divider.Divider v x t) v x
instance GHC.Classes.Ord v => NITTA.Intermediate.Variable.Variables (NITTA.Model.ProcessorUnits.Divider.Job v x t) v


module NITTA.Model.ProcessorUnits.Comparator
data Comparator v x t
compare :: Time t => Comparator v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x t
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) x
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v t
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t)
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Comparator.Comparator v x t) v x


module NITTA.Model.ProcessorUnits.Broken
data Broken v x t
Broken :: [F v x] -> [v] -> [v] -> Maybe t -> Maybe (t, F v x) -> [ProcessStepID] -> Process t (StepInfo v x t) -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Broken v x t
[$sel:remain:Broken] :: Broken v x t -> [F v x]
[$sel:targets:Broken] :: Broken v x t -> [v]
[$sel:sources:Broken] :: Broken v x t -> [v]
[$sel:doneAt:Broken] :: Broken v x t -> Maybe t
[$sel:currentWork:Broken] :: Broken v x t -> Maybe (t, F v x)
[$sel:currentWorkEndpoints:Broken] :: Broken v x t -> [ProcessStepID]
[$sel:process_:Broken] :: Broken v x t -> Process t (StepInfo v x t)

-- | generate verilog code with syntax error
[$sel:brokeVerilog:Broken] :: Broken v x t -> Bool

-- | use process unit HW implementation with error
[$sel:wrongVerilogSimulationValue:Broken] :: Broken v x t -> Bool

-- | wrong control sequence for data push (receiving data to PU)
[$sel:wrongControlOnPush:Broken] :: Broken v x t -> Bool

-- | wrong control sequence for data pull (sending data from PU)
[$sel:wrongControlOnPull:Broken] :: Broken v x t -> Bool

-- | lost target endpoint due synthesis
[$sel:lostEndpointTarget:Broken] :: Broken v x t -> Bool

-- | lost source endpoint due synthesis
[$sel:lostEndpointSource:Broken] :: Broken v x t -> Bool
[$sel:wrongAttr:Broken] :: Broken v x t -> Bool
[$sel:lostFunctionInVerticalRelation:Broken] :: Broken v x t -> Bool
[$sel:lostEndpointInVerticalRelation:Broken] :: Broken v x t -> Bool
[$sel:lostInstructionInVerticalRelation:Broken] :: Broken v x t -> Bool
[$sel:unknownDataOut:Broken] :: Broken v x t -> Bool

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x t
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Broken.Broken v x t))
instance NITTA.Model.Time.Time t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Broken.Broken v x t) x
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Broken.Broken v x t)
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Broken.Broken v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Broken.Broken v x t) v x


module NITTA.Model.ProcessorUnits.Accum
data Accum v x t

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
instance GHC.Show.Show NITTA.Model.ProcessorUnits.Accum.JobState
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Classes.Ord (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Classes.Eq (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance NITTA.Model.Time.VarValTime v x t => Prettyprinter.Internal.Pretty (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.Time.VarValTime v x t => GHC.Show.Show (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.Time.VarValTime v x t => Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.ProcessorUnits.Accum.Accum v x t) x
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x t
instance NITTA.Model.Time.VarValTime v x t => NITTA.Model.Problems.Endpoint.EndpointProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v t
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance Data.Default.Class.Default (NITTA.Model.ProcessorUnits.Types.Microcode (NITTA.Model.ProcessorUnits.Accum.Accum v x t))
instance NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Types.Locks (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.ProcessorUnits.Accum.Accum v x t)
instance GHC.Classes.Ord t => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.ProcessorUnits.Accum.Accum v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.Time.VarValTime v x t => NITTA.Project.TestBench.Testable (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Project.TestBench.IOTestBench (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.ProcessorUnits.Accum.Accum v x t) v x
instance NITTA.Intermediate.Variable.Var v => GHC.Show.Show (NITTA.Model.ProcessorUnits.Accum.Job v x)


-- | A Processor Unit is an element of a NITTA processor that performs data
--   processing, storing, and transferring to and from external devices.
--   
--   <h1>Model of a processor unit</h1>
--   
--   Model of a processor unit includes the following things:
--   
--   <ul>
--   <li>the data type for representation process unit model state, which
--   describes all aspects of its computational process;</li>
--   <li>binding and process description (see <a>ProcessorUnit</a> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>sending and receiving data by the processor unit (see
--   <a>NITTA.Model.Problems.Endpoint</a>);</li>
--   <li>instructions and control signals (see <a>Controllable</a>,
--   <a>UnambiguouslyDecode</a>, and <a>Connected</a> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>refactoring (see <a>NITTA.Model.Problems.Refactor</a>);</li>
--   <li>variables casuality (see <tt>Lock</tt> from
--   <a>NITTA.Intermediate.Types</a>);</li>
--   <li>simulation (see <tt>Simulatable</tt> from
--   <a>NITTA.Model.ProcessorUnits.Time</a>);</li>
--   <li>how to generate hardware with this processor unit
--   (<tt>TargetSystemComponent</tt> from
--   <a>NITTA.Project.Implementation</a>);</li>
--   <li>how to test process unit (see <tt>Testable</tt> from
--   <a>NITTA.Project.TestBench</a>);</li>
--   <li>IO signals and how to test IO if applicable (see
--   <a>IOConnected</a> from <a>Time</a> and <tt>IOTestBench</tt> from
--   <a>NITTA.Project.TestBench</a>);</li>
--   <li>and some technical stuff for it.</li>
--   </ul>
--   
--   For a well-documented example, see
--   <a>NITTA.Model.ProcessorUnits.Multiplier</a>.
--   
--   <h1>HARDWARE INTERFACE of a processor unit</h1>
--   
--   <h2>System signals</h2>
--   
--   <ul>
--   <li><tt>clk</tt> - clock signal;</li>
--   <li><tt>rst</tt> - reset signal;</li>
--   <li><tt>signal_cycle</tt>x - start of computational cycle (require for
--   synchronization reason).</li>
--   </ul>
--   
--   <h2>Control signals</h2>
--   
--   Used for control over a processor unit. A specific set of control
--   signals defined for each process unit individually. Usually, they
--   include:
--   
--   <ul>
--   <li><tt>signal_wr</tt> - the signal for reading data from
--   <tt>data_in</tt>;</li>
--   <li><tt>signal_oe</tt> - the signal for writing data to
--   <tt>data_out</tt>.</li>
--   </ul>
--   
--   <h2>Databus</h2>
--   
--   These ports are used for transferring data between process units.
--   
--   Parameters:
--   
--   <ul>
--   <li><tt>DATA_WIDTH</tt> - machine word width;</li>
--   <li><tt>ATTR_WIDTH</tt> - machine word attribute width;</li>
--   <li><tt>INVALID_ATTR</tt> (default: 0) - index of invalid flag on
--   machine word attribute.</li>
--   </ul>
--   
--   Input ports:
--   
--   <ul>
--   <li>`input [DATA_WIDTH-1:0] data_in` - port for reciving data by a
--   process unit:</li>
--   <li>`input [ATTR_WIDTH-1:0] attr_in` - port for receiving data
--   attributes by a process unit;</li>
--   <li>if <tt>signal_wr</tt> or similar are not set - value on data_in
--   should be ingnored.</li>
--   </ul>
--   
--   Output ports:
--   
--   <ul>
--   <li>`output [DATA_WIDTH-1:0] data_out` - port for sending data to a
--   process unit;</li>
--   <li>`output [ATTR_WIDTH-1:0] attr_out` - port for sending data
--   attributes to a process unit;</li>
--   <li>a processor unit can restrict the time when a value is available
--   for reading;</li>
--   <li>if <tt>signal_oe</tt> or similar are not set - value on
--   <tt>data_out</tt> should be 0, time of <tt>signal_oe</tt> and actual
--   data transfer may variate by the process unit developer:<ul><li>with
--   offset:<pre>signal wave: oe - 0001000 dataout - 0000*00
--   </pre></li><li>without offset:<pre>signal wave: oe - 0001000 dataout -
--   000*000 </pre></li></ul></li>
--   </ul>
--   
--   <h2>External ports or IO ports</h2>
--   
--   Purpose: transferring data from and to the NITTA processor (ports
--   simple forwarded across processor from environment to the processor
--   unit).
--   
--   Acceptable port types: input, output, and input.
--   
--   The composition of ports is determined individually by the type of I/O
--   interface.
module NITTA.Model.ProcessorUnits


module NITTA.UIBackend.Timeline
data ViewPointID
data TimelinePoint t
processTimelines :: (Num t, Typeable v, IsString v, ToString v, Suffix v, Hashable v, Show t, Ord t, Ord v, Enum t) => Process t (StepInfo v x t) -> ProcessTimelines t
data ProcessTimelines t
ProcessTimelines :: [TimelineWithViewPoint t] -> [(ProcessStepID, ProcessStepID)] -> ProcessTimelines t
[$sel:timelines:ProcessTimelines] :: ProcessTimelines t -> [TimelineWithViewPoint t]
[$sel:verticalRelations:ProcessTimelines] :: ProcessTimelines t -> [(ProcessStepID, ProcessStepID)]
data TimelineWithViewPoint t
TimelineWithViewPoint :: ViewPointID -> [[TimelinePoint t]] -> TimelineWithViewPoint t
[$sel:timelineViewpoint:TimelineWithViewPoint] :: TimelineWithViewPoint t -> ViewPointID
[$sel:timelinePoints:TimelineWithViewPoint] :: TimelineWithViewPoint t -> [[TimelinePoint t]]
instance GHC.Generics.Generic NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Classes.Ord NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Classes.Eq NITTA.UIBackend.Timeline.ViewPointID
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.TimelinePoint t)
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.TimelineWithViewPoint t)
instance GHC.Generics.Generic (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance NITTA.Model.Time.Time t => GHC.Show.Show (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.ProcessTimelines t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.Timeline.ProcessTimelines GHC.Types.Int)
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.TimelineWithViewPoint t)
instance NITTA.Model.Time.Time t => GHC.Show.Show [NITTA.UIBackend.Timeline.TimelinePoint t]
instance (NITTA.Model.Time.Time t, Data.Aeson.Types.ToJSON.ToJSON t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.Timeline.TimelinePoint t)
instance GHC.Show.Show NITTA.UIBackend.Timeline.ViewPointID
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.Timeline.ViewPointID


module NITTA.Model.TargetSystem

-- | Model of target unit, which is a main subject of synthesis process and
--   synthesis graph.
data TargetSystem u tag v x t
TargetSystem :: u -> DataFlowGraph v x -> TargetSystem u tag v x t

-- | model of target unit
[mUnit] :: TargetSystem u tag v x t -> u

-- | whole application algorithm
[mDataFlowGraph] :: TargetSystem u tag v x t -> DataFlowGraph v x
processDuration :: (Num a, NextTick u a) => TargetSystem u tag v x t -> a
isSynthesisComplete :: ProcessorUnit u v x t => TargetSystem u tag v x t -> Bool
instance GHC.Generics.Generic (NITTA.Model.TargetSystem.TargetSystem u tag v x t)
instance Data.Default.Class.Default u => Data.Default.Class.Default (NITTA.Model.TargetSystem.TargetSystem u tag v x t)
instance NITTA.Intermediate.Types.WithFunctions u (NITTA.Intermediate.Types.F v x) => NITTA.Intermediate.Types.WithFunctions (NITTA.Model.TargetSystem.TargetSystem u tag v x t) (NITTA.Intermediate.Types.F v x)
instance NITTA.Model.ProcessorUnits.Types.ProcessorUnit u v x t => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x t
instance NITTA.Model.Problems.Bind.BindProblem u tag v x => NITTA.Model.Problems.Bind.BindProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) tag v x
instance NITTA.Model.Problems.Dataflow.DataflowProblem u tag v t => NITTA.Model.Problems.Dataflow.DataflowProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) tag v t
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem u v x) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem u v x) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x, NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem u v x) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem u v x) => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) v x
instance NITTA.Model.Problems.Allocation.AllocationProblem u tag => NITTA.Model.Problems.Allocation.AllocationProblem (NITTA.Model.TargetSystem.TargetSystem u tag v x t) tag


module NITTA.Model.ProcessIntegrity
class ProcessIntegrity u
checkProcessIntegrity :: ProcessIntegrity u => u -> Either String ()
instance NITTA.Model.ProcessorUnits.Types.ProcessorUnit (pu v x t) v x t => NITTA.Model.ProcessIntegrity.ProcessIntegrity (pu v x t)

module NITTA.Model.Problems.ViewHelper
data DecisionView
RootView :: DecisionView
SingleBindView :: FView -> Text -> DecisionView
[$sel:function:RootView] :: DecisionView -> FView
[$sel:pu:RootView] :: DecisionView -> Text
GroupBindView :: HashMap Text [FView] -> DecisionView
[$sel:bindGroup:RootView] :: DecisionView -> HashMap Text [FView]
AllocationView :: Text -> Text -> DecisionView
[$sel:networkTag:RootView] :: DecisionView -> Text
[$sel:processUnitTag:RootView] :: DecisionView -> Text
DataflowDecisionView :: (Text, EndpointSt Text (Interval Int)) -> [(Text, EndpointSt Text (Interval Int))] -> DecisionView
[$sel:source:RootView] :: DecisionView -> (Text, EndpointSt Text (Interval Int))
[$sel:targets:RootView] :: DecisionView -> [(Text, EndpointSt Text (Interval Int))]
BreakLoopView :: Text -> [Text] -> Text -> DecisionView
[$sel:value:RootView] :: DecisionView -> Text
[$sel:outputs:RootView] :: DecisionView -> [Text]
[$sel:input:RootView] :: DecisionView -> Text
ConstantFoldingView :: [FView] -> [FView] -> DecisionView
[$sel:cRefOld:RootView] :: DecisionView -> [FView]
[$sel:cRefNew:RootView] :: DecisionView -> [FView]
OptimizeAccumView :: [FView] -> [FView] -> DecisionView
[$sel:old:RootView] :: DecisionView -> [FView]
[$sel:new:RootView] :: DecisionView -> [FView]
ResolveDeadlockView :: Text -> Text -> DecisionView
[$sel:newBuffer:RootView] :: DecisionView -> Text
[$sel:changeset:RootView] :: DecisionView -> Text
newtype IntervalView
IntervalView :: Text -> IntervalView
instance GHC.Generics.Generic NITTA.Model.Problems.ViewHelper.IntervalView
instance GHC.Generics.Generic NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Bind.Bind tag v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Allocation.Allocation tag) NITTA.Model.Problems.ViewHelper.DecisionView
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Dataflow.DataflowSt tag v (Numeric.Interval.NonEmpty.Internal.Interval t)) NITTA.Model.Problems.ViewHelper.DecisionView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Intermediate.Value.Val x) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Intermediate.Variable.Var v => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) NITTA.Model.Problems.ViewHelper.DecisionView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Problems.ViewHelper.DecisionView
instance NITTA.Model.Time.Time t => NITTA.UIBackend.ViewHelperCls.Viewable (Numeric.Interval.NonEmpty.Internal.Interval t) NITTA.Model.Problems.ViewHelper.IntervalView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Problems.ViewHelper.IntervalView


module NITTA.Model.Networks.Bus
data BusNetwork tag v x t
BusNetwork :: tag -> [F v x] -> Map tag [F v x] -> Process t (StepInfo v x t) -> Map tag (PU v x t) -> Int -> IOSynchronization -> UnitEnv (BusNetwork tag v x t) -> Map tag (PUPrototype tag v x t) -> BusNetwork tag v x t
[bnName] :: BusNetwork tag v x t -> tag

-- | List of functions bound to network, but not bound to any process unit.
[bnRemains] :: BusNetwork tag v x t -> [F v x]

-- | Map process unit name to list of bound functions.
[bnBound] :: BusNetwork tag v x t -> Map tag [F v x]

-- | Network process (bindings and transport instructions)
[bnProcess] :: BusNetwork tag v x t -> Process t (StepInfo v x t)

-- | Map of process units.
[bnPus] :: BusNetwork tag v x t -> Map tag (PU v x t)

-- | Controll bus width.
[bnSignalBusWidth] :: BusNetwork tag v x t -> Int
[ioSync] :: BusNetwork tag v x t -> IOSynchronization
[bnEnv] :: BusNetwork tag v x t -> UnitEnv (BusNetwork tag v x t)

-- | Set of the PUs that could be added to the network during synthesis
--   process
[bnPUPrototypes] :: BusNetwork tag v x t -> Map tag (PUPrototype tag v x t)
data Instruction pu :: Type

-- | A processor unit control ports (signals, flags).
data Ports pu :: Type
data IOPorts pu :: Type
boundFunctions :: Ord k => k -> BusNetwork k v x t -> [F v x]
controlSignalLiteral :: (Builder (IsCustomSink dst) dst ~ Builder (IsCustomSink dst) dst, Interpolatable (IsCustomSink dst) src dst) => src -> dst
busNetwork :: Default t => tag -> IOSynchronization -> BusNetwork tag v x t
modifyNetwork :: BusNetwork k v x t -> State (BuilderSt k v x t) a -> BusNetwork k v x t
defineNetwork :: Default t => k -> IOSynchronization -> State (BuilderSt k v x t) a -> BusNetwork k v x t
addCustom :: forall tag v x t m pu. (MonadState (BuilderSt tag v x t) m, PUClasses pu v x t, UnitTag tag) => tag -> pu -> IOPorts pu -> m ()

-- | Add PU with the default initial state. Type specify by IOPorts.
add :: (MonadState (BuilderSt tag v x t) m, PUClasses pu v x t, Default pu, UnitTag tag) => tag -> IOPorts pu -> m ()

-- | Add PU to prototypes with the default initial state. Type specify by
--   IOPorts.
addPrototype :: (MonadState (BuilderSt tag v x t) m, PUClasses pu v x t, Default pu, UnitTag tag) => tag -> IOPorts pu -> m ()
addCustomPrototype :: forall tag v x t m pu. (MonadState (BuilderSt tag v x t) m, PUClasses pu v x t, UnitTag tag) => tag -> pu -> IOPorts pu -> m ()
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Ports (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.IOPorts (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance (Data.Default.Class.Default t, Data.String.IsString tag) => Data.Default.Class.Default (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Intermediate.Variable.Var v => NITTA.Intermediate.Variable.Variables (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v
instance Data.Default.Class.Default x => NITTA.Intermediate.Value.DefaultX (NITTA.Model.Networks.Bus.BusNetwork tag v x t) x
instance NITTA.Intermediate.Types.WithFunctions (NITTA.Model.Networks.Bus.BusNetwork tag v x t) (NITTA.Intermediate.Types.F v x)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Dataflow.DataflowProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v t
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x t
instance NITTA.Model.ProcessorUnits.Types.Controllable (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance (Data.String.ToString.ToString tag, NITTA.Intermediate.Variable.Var v) => GHC.Show.Show (NITTA.Model.ProcessorUnits.Types.Instruction (NITTA.Model.Networks.Bus.BusNetwork tag v x t))
instance NITTA.Model.ProcessorUnits.Types.ByTime (NITTA.Model.Networks.Bus.BusNetwork tag v x t) t
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Bind.BindProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.BreakLoop.BreakLoopProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccumProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFoldingProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlockProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => NITTA.Model.Problems.Allocation.AllocationProblem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.Types.TargetSystemComponent (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Model.ProcessorUnits.Types.Connected (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance NITTA.Model.ProcessorUnits.Types.IOConnected (NITTA.Model.Networks.Bus.BusNetwork tag v x t)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Project.TestBench.Testable (NITTA.Model.Networks.Bus.BusNetwork tag v x t) v x


-- | Synthesis can be represented as a graph (tree), where each
--   <tt>Node</tt> describes the target system <tt>ModelState</tt> and each
--   <tt>Edge</tt> synthesis decision.
--   
--   A synthesis graph is very large and calculating and storing it in
--   memory is very bad idea. Also, working with synthesis graph usually
--   making from the specific node, not from the root. As a result,
--   synthesis graph design as a explicit lazy mutable structure
--   implemented by <tt>TVar</tt>.
--   
--   From this point of view, the synthesis process is a finding of the
--   best tree leaf (lowest process duration for finished synthesis), and
--   the best synthesis method - a method which directly walks over the
--   tree to the best leaf without wrong steps.
module NITTA.Synthesis.Types
class SynthesisDecisionCls ctx m o d p | ctx o -> m d p
decisions :: SynthesisDecisionCls ctx m o d p => ctx -> o -> [(d, m)]
parameters :: SynthesisDecisionCls ctx m o d p => ctx -> o -> d -> p
estimate :: SynthesisDecisionCls ctx m o d p => ctx -> o -> d -> p -> Float

-- | Synthesis tree
data Tree m tag v x t
Tree :: Sid -> SynthesisState m tag v x t -> SynthesisDecision (SynthesisState m tag v x t) m -> TMVar [Tree m tag v x t] -> Bool -> Bool -> Tree m tag v x t
[sID] :: Tree m tag v x t -> Sid
[sState] :: Tree m tag v x t -> SynthesisState m tag v x t
[sDecision] :: Tree m tag v x t -> SynthesisDecision (SynthesisState m tag v x t) m

-- | lazy mutable field with different synthesis options and sub nodes
[sSubForestVar] :: Tree m tag v x t -> TMVar [Tree m tag v x t]
[isLeaf] :: Tree m tag v x t -> Bool
[isComplete] :: Tree m tag v x t -> Bool
data SynthesisDecision ctx m
[Root] :: SynthesisDecision ctx m
[SynthesisDecision] :: (Typeable p, SynthesisDecisionCls ctx m o d p, Show d, ToJSON p, Viewable d DecisionView) => o -> d -> p -> Map Text Float -> SynthesisDecision ctx m
data SynthesisState m tag v x t
SynthesisState :: Maybe (Tree m tag v x t) -> m -> [Allocation tag] -> [Bind tag v x] -> [ResolveDeadlock v x] -> [OptimizeAccum v x] -> [ConstantFolding v x] -> [BreakLoop v x] -> [DataflowSt tag v (TimeConstraint t)] -> Map (F v x) [tag] -> Set (F v x) -> Map v Int -> [ProcessWave v x] -> Int -> Int -> Set v -> Map tag Int -> SynthesisState m tag v x t
[sParent] :: SynthesisState m tag v x t -> Maybe (Tree m tag v x t)
[sTarget] :: SynthesisState m tag v x t -> m

-- | PU allocation options cache
[sAllocationOptions] :: SynthesisState m tag v x t -> [Allocation tag]

-- | bind options cache
[sBindOptions] :: SynthesisState m tag v x t -> [Bind tag v x]
[sResolveDeadlockOptions] :: SynthesisState m tag v x t -> [ResolveDeadlock v x]
[sOptimizeAccumOptions] :: SynthesisState m tag v x t -> [OptimizeAccum v x]
[sConstantFoldingOptions] :: SynthesisState m tag v x t -> [ConstantFolding v x]
[sBreakLoopOptions] :: SynthesisState m tag v x t -> [BreakLoop v x]

-- | dataflow options cache
[sDataflowOptions] :: SynthesisState m tag v x t -> [DataflowSt tag v (TimeConstraint t)]

-- | a map from functions to possible processor unit tags
[bindingAlternative] :: SynthesisState m tag v x t -> Map (F v x) [tag]

-- | a function set, which binding may cause dead lock
[possibleDeadlockBinds] :: SynthesisState m tag v x t -> Set (F v x)

-- | if algorithm will be represented as a graph, where nodes - variables
--   of not bound functions, edges - casuality, wave is a minimal number of
--   a step from an initial node to selected
[bindWaves] :: SynthesisState m tag v x t -> Map v Int

-- | Execution waves of the algorithm. See detailed description in
--   NITTA.Intermediate.Analysis module.
[processWaves] :: SynthesisState m tag v x t -> [ProcessWave v x]

-- | Number of execution waves of the algorithm.
[numberOfProcessWaves] :: SynthesisState m tag v x t -> Int

-- | number of dataflow options
[numberOfDataflowOptions] :: SynthesisState m tag v x t -> Int

-- | a variable set, which can be transferred on the current synthesis step
[transferableVars] :: SynthesisState m tag v x t -> Set v

-- | dictionary with number of bound functions for each unit
[unitWorkloadInFunction] :: SynthesisState m tag v x t -> Map tag Int

-- | Shortcut for constraints in signatures of synthesis method functions.
--   This used to be (VarValTime v x t, UnitTag tag). See below for more
--   info.
type SynthesisMethodConstraints tag v x t = (VarValTimeJSON v x t, ToJSON tag, UnitTag tag)

-- | Synthesis node ID. ID is a relative path, encoded as a sequence of an
--   option index.
newtype Sid
Sid :: [Int] -> Sid

-- | Default synthesis tree type.
type DefTree tag v x t = Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t

-- | The synthesis method is a function, which manipulates a synthesis
--   tree. It receives a node and explores it deeply by IO.
type SynthesisMethod tag v x t = DefTree tag v x t -> IO (DefTree tag v x t)
(<?>) :: Num p => Bool -> p -> p
targetUnit :: Tree (TargetSystem c tag v x t) tag v x t -> c
targetDFG :: Tree (TargetSystem u tag v x t) tag v x t -> DataFlowGraph v x
defScore :: SynthesisDecision ctx m -> Float
mlScoreKeyPrefix :: IsString a => a
instance GHC.Show.Show NITTA.Synthesis.Types.Sid
instance GHC.Read.Read NITTA.Synthesis.Types.Sid
instance Data.Default.Class.Default NITTA.Synthesis.Types.Sid
instance GHC.Base.Semigroup NITTA.Synthesis.Types.Sid
instance GHC.Base.Monoid NITTA.Synthesis.Types.Sid
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Types.Sid
instance Web.Internal.HttpApiData.FromHttpApiData NITTA.Synthesis.Types.Sid


module NITTA.UIBackend.Types
data BackendCtx tag v x t
BackendCtx :: DefTree tag v x t -> [(v, [x])] -> String -> IO MlBackendServer -> [Text] -> BackendCtx tag v x t

-- | root synthesis node
[root] :: BackendCtx tag v x t -> DefTree tag v x t

-- | lists of received by IO values
[receivedValues] :: BackendCtx tag v x t -> [(v, [x])]
[outputPath] :: BackendCtx tag v x t -> String
[mlBackendGetter] :: BackendCtx tag v x t -> IO MlBackendServer

-- | list of node scores name. Used for ML backend mostly, but can be used
--   for any "hardcoded" scoring function.
[nodeScores] :: BackendCtx tag v x t -> [Text]
instance Data.Default.Class.Default (NITTA.UIBackend.Types.BackendCtx tag v x t)


module NITTA.Synthesis.Analysis
getTreeInfo :: (VarValTime v x t, NextTick u t) => Tree (TargetSystem u tag v x t) tag v x t -> IO TreeInfo

-- | Metrics of synthesis tree process
data TreeInfo
TreeInfo :: !Int -> !Int -> !Int -> !Int -> HashMap Int Int -> HashMap Int Int -> TreeInfo
[nodesVisited] :: TreeInfo -> !Int
[nodesSuccess] :: TreeInfo -> !Int
[nodesFailed] :: TreeInfo -> !Int
[nodesNotProcessed] :: TreeInfo -> !Int
[targetProcessDuration] :: TreeInfo -> HashMap Int Int
[synthesisStepsForSuccess] :: TreeInfo -> HashMap Int Int
instance GHC.Show.Show NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Generics.Generic NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Base.Semigroup NITTA.Synthesis.Analysis.TreeInfo
instance GHC.Base.Monoid NITTA.Synthesis.Analysis.TreeInfo


module NITTA.Synthesis.Steps.ResolveDeadlock
data ResolveDeadlockMetrics
ResolveDeadlockMetrics :: Float -> Float -> Float -> ResolveDeadlockMetrics
[pNumberOfLockedVariables] :: ResolveDeadlockMetrics -> Float
[pBufferCount] :: ResolveDeadlockMetrics -> Float
[pNumberOfTransferableVariables] :: ResolveDeadlockMetrics -> Float
instance GHC.Generics.Generic NITTA.Synthesis.Steps.ResolveDeadlock.ResolveDeadlockMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.ResolveDeadlock.ResolveDeadlockMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) (NITTA.Model.Problems.Refactor.ResolveDeadlock.ResolveDeadlock v x) NITTA.Synthesis.Steps.ResolveDeadlock.ResolveDeadlockMetrics


module NITTA.Synthesis.Steps.OptimizeAccum
data OptimizeAccumMetrics
OptimizeAccumMetrics :: OptimizeAccumMetrics
instance GHC.Generics.Generic NITTA.Synthesis.Steps.OptimizeAccum.OptimizeAccumMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.OptimizeAccum.OptimizeAccumMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) (NITTA.Model.Problems.Refactor.OptimizeAccum.OptimizeAccum v x) NITTA.Synthesis.Steps.OptimizeAccum.OptimizeAccumMetrics


module NITTA.Synthesis.Steps.Dataflow
data DataflowMetrics
DataflowMetrics :: Float -> Bool -> [Float] -> Float -> DataflowMetrics
[pWaitTime] :: DataflowMetrics -> Float
[pRestrictedTime] :: DataflowMetrics -> Bool

-- | number of variables, which is not transferable for affected functions.
[pNotTransferableInputs] :: DataflowMetrics -> [Float]

-- | number of the first wave in which one of the target variables is used
[pFirstWaveOfTargetUse] :: DataflowMetrics -> Float
instance GHC.Generics.Generic NITTA.Synthesis.Steps.Dataflow.DataflowMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.Dataflow.DataflowMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Dataflow.DataflowSt tag v (NITTA.Model.Time.TimeConstraint t)) (NITTA.Model.Problems.Dataflow.DataflowSt tag v (Numeric.Interval.NonEmpty.Internal.Interval t)) NITTA.Synthesis.Steps.Dataflow.DataflowMetrics


module NITTA.Synthesis.Steps.ConstantFolding
data ConstantFoldingMetrics
ConstantFoldingMetrics :: ConstantFoldingMetrics
instance GHC.Generics.Generic NITTA.Synthesis.Steps.ConstantFolding.ConstantFoldingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.ConstantFolding.ConstantFoldingMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) (NITTA.Model.Problems.Refactor.ConstantFolding.ConstantFolding v x) NITTA.Synthesis.Steps.ConstantFolding.ConstantFoldingMetrics


module NITTA.Synthesis.Steps.BreakLoop
data BreakLoopMetrics
BreakLoopMetrics :: BreakLoopMetrics
instance GHC.Generics.Generic NITTA.Synthesis.Steps.BreakLoop.BreakLoopMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.BreakLoop.BreakLoopMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) (NITTA.Model.Problems.Refactor.BreakLoop.BreakLoop v x) NITTA.Synthesis.Steps.BreakLoop.BreakLoopMetrics


module NITTA.Synthesis.Steps.Bind
data BindMetrics
SingleBindMetrics :: Bool -> Float -> Float -> Float -> Float -> Bool -> Float -> Float -> Maybe Float -> BindMetrics

-- | Can this binding block another one (for example, one <tt>Loop</tt> can
--   take the last free buffer)?
[pCritical] :: BindMetrics -> Bool

-- | How many alternative binding we have?
[pAlternative] :: BindMetrics -> Float

-- | How many ticks requires for executing the function?
[pRestless] :: BindMetrics -> Float
[pOutputNumber] :: BindMetrics -> Float

-- | How many transactions can be executed with this function?
[pAllowDataFlow] :: BindMetrics -> Float

-- | May this binding cause deadlock?
[pPossibleDeadlock] :: BindMetrics -> Bool
[pNumberOfBoundFunctions] :: BindMetrics -> Float

-- | number of bound input variables / number of all input variables
[pPercentOfBoundInputs] :: BindMetrics -> Float
[pWave] :: BindMetrics -> Maybe Float
GroupBindMetrics :: Bool -> Float -> Float -> Float -> Float -> Float -> BindMetrics

-- | We don't have alternatives for binding
[pOnlyObviousBinds] :: BindMetrics -> Bool

-- | number of bound functions / number of all functions in DFG
[pFunctionPercentInBinds] :: BindMetrics -> Float

-- | average number of binds per unit
[pAvgBinds] :: BindMetrics -> Float

-- | variance of binds per unit
[pVarianceBinds] :: BindMetrics -> Float

-- | average number of variables after bind per unit
[pAvgUnitWorkload] :: BindMetrics -> Float

-- | variance of variables after bind per unit
[pVarianceUnitWorkload] :: BindMetrics -> Float
isSingleBind :: SynthesisDecision ctx m -> Bool
isMultiBind :: SynthesisDecision ctx m -> Bool
isObviousMultiBind :: SynthesisDecision ctx m -> Bool
instance GHC.Generics.Generic NITTA.Synthesis.Steps.Bind.BindMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.Bind.BindMetrics
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Bind.Bind tag v x) (NITTA.Model.Problems.Bind.Bind tag v x) NITTA.Synthesis.Steps.Bind.BindMetrics


module NITTA.Synthesis.Steps.Allocation
data AllocationMetrics
AllocationMetrics :: ParallelismType -> Float -> Float -> Float -> Float -> AllocationMetrics

-- | PU prototype parallelism type
[mParallelism] :: AllocationMetrics -> ParallelismType

-- | The number of remaining functions that can be bound to pu
[mRelatedRemains] :: AllocationMetrics -> Float

-- | The minimum number of PUs for each of the remaining functions that can
--   process it
[mMinPusForRemains] :: AllocationMetrics -> Float

-- | The maximum number of functions that could be processed in parallel
[mMaxParallels] :: AllocationMetrics -> Float

-- | The number of functions that can be processed in parallel on average
[mAvgParallels] :: AllocationMetrics -> Float
instance GHC.Generics.Generic NITTA.Synthesis.Steps.Allocation.AllocationMetrics
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Steps.Allocation.AllocationMetrics
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => NITTA.Synthesis.Types.SynthesisDecisionCls (NITTA.Synthesis.Types.SynthesisState (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) tag v x t) (NITTA.Model.TargetSystem.TargetSystem (NITTA.Model.Networks.Bus.BusNetwork tag v x t) tag v x t) (NITTA.Model.Problems.Allocation.Allocation tag) (NITTA.Model.Problems.Allocation.Allocation tag) NITTA.Synthesis.Steps.Allocation.AllocationMetrics


module NITTA.Synthesis.Steps
isRefactor :: SynthesisDecision ctx m -> Bool


-- | We can not autogenerate ToJSON implementation for some types, so we
--   add helper types for doing that automatically. Why do we need to
--   generate <a>ToJSON</a> automatically? We don't want to achieve
--   consistency between client and server manually.
module NITTA.UIBackend.ViewHelper

-- | Helper for JSON serialization
data FView
FView :: Text -> [Text] -> FView
[fvFun] :: FView -> Text
[fvHistory] :: FView -> [Text]

-- | Type class of helpers required for autogeneration of ToJSON and
--   typescript types.
class Viewable t v | t -> v
view :: Viewable t v => t -> v
viewNodeTree :: (Enum b, Num b, NextTick u b) => Tree (TargetSystem u tag v x t) tag v x t -> IO (TreeView ShortNodeView)
data TreeView a
data ShortNodeView
data NodeView tag v x t
newtype StepInfoView
StepInfoView :: Text -> StepInfoView
type VarValTimeJSON v x t = (VarValTime v x t, ToJSONKey v, ToJSON v, ToJSON x, ToJSON t)
instance GHC.Show.Show a => GHC.Show.Show (NITTA.UIBackend.ViewHelper.TreeView a)
instance GHC.Generics.Generic (NITTA.UIBackend.ViewHelper.TreeView a)
instance GHC.Show.Show NITTA.UIBackend.ViewHelper.ShortNodeView
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.ShortNodeView
instance GHC.Show.Show NITTA.UIBackend.ViewHelper.NodeInfo
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.NodeInfo
instance GHC.Generics.Generic (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance GHC.Generics.Generic NITTA.UIBackend.ViewHelper.StepInfoView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.ProcessorUnits.Types.StepInfo v x t) NITTA.UIBackend.ViewHelper.StepInfoView
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.ViewHelper.StepInfoView
instance (NITTA.Intermediate.Variable.Var v, NITTA.Model.Time.Time t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Model.ProcessorUnits.Types.Process t (NITTA.Model.ProcessorUnits.Types.StepInfo v x t)) (NITTA.Model.ProcessorUnits.Types.Process t NITTA.UIBackend.ViewHelper.StepInfoView)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTimeJSON v x t) => NITTA.UIBackend.ViewHelperCls.Viewable (NITTA.Synthesis.Types.DefTree tag v x t) (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance (NITTA.Model.Time.VarValTimeJSON v x t, Data.Aeson.Types.ToJSON.ToJSON tag) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.ViewHelper.NodeView tag v x t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.ViewHelper.TreeView NITTA.UIBackend.ViewHelper.ShortNodeView)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.UIBackend.ViewHelper.ShortNodeView
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.ViewHelper.TreeView a)
instance Servant.Docs.Internal.ToSample GHC.Num.Integer.Integer
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.Analysis.TreeInfo
instance Servant.Docs.Internal.ToSample NITTA.Synthesis.Analysis.TreeInfo
instance (Data.Aeson.Types.ToJSON.ToJSONKey v, Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON x) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Project.TestBench.TestbenchReport v x)
instance Servant.Docs.Internal.ToSample (NITTA.Project.TestBench.TestbenchReport GHC.Base.String GHC.Types.Int)


module NITTA.Synthesis.MlBackend.Client
data ScoringInput tag v x t
ScoringInput :: ScoringTarget -> [NodeView tag v x t] -> ScoringInput tag v x t
[scoringTarget] :: ScoringInput tag v x t -> ScoringTarget
[nodes] :: ScoringInput tag v x t -> [NodeView tag v x t]
data ScoringTarget
ScoringTargetSid :: Sid -> ScoringTarget
ScoringTargetAll :: ScoringTarget
predictScoresIO :: forall {m} {v} {x} {t} {a} {tag}. (IsString v, Suffix v, Hashable v, Val x, Bounded t, ToJSONKey v, MonadThrow m, ToString v, ToString a, MonadIO m, Typeable v, Typeable t, Show t, Default t, Integral t, Ord v, ToJSON v, ToJSON t, ToJSON tag) => Text -> a -> [ScoringInput tag v x t] -> m [[Float]]
instance GHC.Generics.Generic (NITTA.Synthesis.MlBackend.Client.ScoringInput tag v x t)
instance GHC.Generics.Generic (NITTA.Synthesis.MlBackend.Client.PostScoreRequestBody tag v x t)
instance GHC.Generics.Generic (NITTA.Synthesis.MlBackend.Client.MlBackendResponse d)
instance GHC.Show.Show d => GHC.Show.Show (NITTA.Synthesis.MlBackend.Client.MlBackendResponse d)
instance GHC.Generics.Generic NITTA.Synthesis.MlBackend.Client.PostScoreResponseData
instance GHC.Show.Show NITTA.Synthesis.MlBackend.Client.PostScoreResponseData
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.MlBackend.Client.PostScoreResponseData
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Synthesis.MlBackend.Client.PostScoreResponseData
instance Data.Aeson.Types.FromJSON.FromJSON d => Data.Aeson.Types.FromJSON.FromJSON (NITTA.Synthesis.MlBackend.Client.MlBackendResponse d)
instance Data.Aeson.Types.ToJSON.ToJSON d => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Synthesis.MlBackend.Client.MlBackendResponse d)
instance (NITTA.Model.Time.VarValTimeJSON v x t, Data.Aeson.Types.ToJSON.ToJSON tag) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Synthesis.MlBackend.Client.PostScoreRequestBody tag v x t)
instance (NITTA.Model.Time.VarValTimeJSON v x t, Data.Aeson.Types.ToJSON.ToJSON tag) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Synthesis.MlBackend.Client.ScoringInput tag v x t)
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Synthesis.MlBackend.Client.ScoringTarget


module NITTA.Synthesis.Explore

-- | Make synthesis tree
synthesisTreeRootIO :: (UnitTag tag, Val x, Bounded t, Hashable v, Suffix v, Show t, Default t, Integral t, Typeable t, Typeable v, Ord v, ToString v, IsString v) => TargetSystem (BusNetwork tag v x t) tag v x t -> IO (Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t)

-- | Get specific by <tt>nId</tt> node from a synthesis tree.
getTreeIO :: (UnitTag tag, Hashable v, Suffix v, Val x, Bounded t, ToJSONKey v, Show t, Default t, Integral t, ToJSON v, ToJSON t, ToJSON tag, Typeable v, Typeable t, Ord v, ToString v, IsString v) => BackendCtx tag v x t -> Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> Sid -> IO (Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t)

-- | Get list of all nodes from root to selected.
getTreePathIO :: (UnitTag tag, Hashable v, Suffix v, Val x, Bounded t, ToJSONKey v, Show t, Default t, Integral t, ToJSON v, ToJSON t, ToJSON tag, Typeable v, Typeable t, Ord v, ToString v, IsString v) => BackendCtx tag v x t -> Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> Sid -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]

-- | Get all available edges for the node. Edges calculated only for the
--   first call.
subForestIO :: (UnitTag tag, Hashable v, Suffix v, Val x, Bounded t, ToJSONKey v, ToJSON v, ToJSON t, ToJSON tag, Show t, Default t, Integral t, Typeable v, Typeable t, Ord v, ToString v, IsString v) => BackendCtx tag v x t -> Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]

-- | For synthesis method is more usefull, because throw away all useless
--   trees in subForest (objective function value less than zero).
positiveSubForestIO :: (UnitTag tag, Hashable v, Suffix v, Val x, Bounded t, ToJSONKey v, Show t, Default t, Integral t, ToJSON v, ToJSON t, ToJSON tag, Typeable v, Typeable t, Ord v, ToString v, IsString v) => BackendCtx tag v x t -> Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t -> IO [Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t]


module NITTA.Synthesis.Method

-- | Default synthesis tree type.
type DefTree tag v x t = Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t

-- | The synthesis method is a function, which manipulates a synthesis
--   tree. It receives a node and explores it deeply by IO.
type SynthesisMethod tag v x t = DefTree tag v x t -> IO (DefTree tag v x t)
noSynthesis :: BackendCtx tag v x t -> SynthesisMethod tag v x t

-- | Schedule process by simple synthesis.
simpleSynthesisIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t
smartBindSynthesisIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t
obviousBindThreadIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t
topDownByScoreSynthesisIO :: SynthesisMethodConstraints tag v x t => Float -> Int -> Maybe Text -> BackendCtx tag v x t -> SynthesisMethod tag v x t
allBestThreadIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> Int -> SynthesisMethod tag v x t

-- | The most complex synthesis method, which embedded all another. That
--   all.
stateOfTheArtSynthesisIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t
allBindsAndRefsIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t
bestStepIO :: SynthesisMethodConstraints tag v x t => BackendCtx tag v x t -> SynthesisMethod tag v x t

-- | Shortcut for constraints in signatures of synthesis method functions.
--   This used to be (VarValTime v x t, UnitTag tag). See below for more
--   info.
type SynthesisMethodConstraints tag v x t = (VarValTimeJSON v x t, ToJSON tag, UnitTag tag)


-- | TargetSynthesis is an entry point for synthesis process.
--   TargetSynthesis flow shown on fig.
--   
--   <pre>
--   ====================================================================================================================
--                                                                                                                Prepare
--   NITTA.Synthesis:TargetSynthesis                                                                     NITTA.Project...
--       # tName                                                                              NITTA.Frontends
--       # tMicroArch -----------------------------
--       # tSourceCode -+                          |     /--+-- mkModelWithOneNetwork
--                      |                          |     |  |
--                      *&lt;-translate               |     |  |
--                      |                          |     |  v      NITTA.Model:TargetSystem----------
--       # tDFG <a>+--------*--------</a> # mUnit         |             |    NITTA.Model...
--           |                                        |                                |             |     /-----------
--           |                                        v                                |             |     |  Target   |
--           +----------------------------------------*-----------&gt; # mDataFlowGraph   |             -----+  System   |
--                                                                                     |                   | Imitation |
--       # tReceivedValues                                                             |                   |   Model   |
--       # tVerbose                                                                    |                   -----------/
--       # tSynthesisMethod ----------------------------------                        |
--                                                            |                        |
--                                                            |                        |
--   ===================================================================================================================
--                                                            |                        |               Synthesis process
--           NITTA.Synthesis.Types:Tree                       |                        |           NITTA.Synthesis.Types
--               # sID                                        |                        |          NITTA.Synthesis.Method
--               # sState &lt;------------------------------------------------------------+
--               # sDecision                                  |
--                   # option                                 |
--                   # decision                               *&lt;-- search for best synthesis path
--                   # metrics                                |
--                   # score                                  v
--               # sSubForestVar -------------------------&gt;/<i> * </i>/ -----
--                                                                      |
--                                                                      v
--                                                               NITTA.Synthesis.Types:Tree
--                                                                   # sState
--                                                                       # sTarget
--                                          /------------------------------- # mUnit
--                                          |        /---------------------- # mDataFlowGraph
--                                          |        |                   # ...
--                                          |        |               # ...
--                                          |        |
--   ===================================================================================================================
--                                          |        |                                         Target project generation
--   NITTA.Project.Types:Project            |        |                                                 NITTA.Project....
--    |      # pName &lt;--------- $tName      |        |
--    |      # pLibPath                     |        +&lt;----- $tReceivedValues
--    |      # pTargetProjectPath           |        |
--    |      # pModel&lt;----------------------/        *&lt;----- functional simulation (FIXME)
--    |                                              |
--    |      # pTestCntx &lt;---------------------------/
--    |
--    |
--    *&lt;---------- $writeProject
--    |                # TargetSystem
--    |                    # hardware
--    |                    # software
--    |                # TestBench
--    |                # Templates
--    |
--    ---&gt; filesystem
--   </pre>
module NITTA.Synthesis

-- | Make a model of NITTA process with one network and a specific
--   algorithm. All functions are already bound to the network.
mkModelWithOneNetwork :: ProcessorUnit u v x t => u -> DataFlowGraph v x -> TargetSystem u tag v x t

-- | Description of synthesis task. Applicable for target system synthesis
--   and testing purpose.
data TargetSynthesis tag v x t
TargetSynthesis :: String -> BusNetwork tag v x t -> Maybe Text -> DataFlowGraph v x -> [(v, [x])] -> SynthesisMethod tag v x t -> String -> String -> [FilePath] -> Int -> FrontendType -> TargetSynthesis tag v x t

-- | target name, used for top level module name and project path
[tName] :: TargetSynthesis tag v x t -> String

-- | composition of processor units, IO ports and its interconnect
[tMicroArch] :: TargetSynthesis tag v x t -> BusNetwork tag v x t

-- | optional application source code (lua)
[tSourceCode] :: TargetSynthesis tag v x t -> Maybe Text

-- | algorithm in intermediate data flow graph representation (if
--   tSourceCode present will be overwritten)
[tDFG] :: TargetSynthesis tag v x t -> DataFlowGraph v x

-- | values from input interface for testing purpose
[tReceivedValues] :: TargetSynthesis tag v x t -> [(v, [x])]

-- | synthesis method
[tSynthesisMethod] :: TargetSynthesis tag v x t -> SynthesisMethod tag v x t

-- | IP-core library directory
[tLibPath] :: TargetSynthesis tag v x t -> String

-- | output directory, where CAD create project directory with <a>tName</a>
--   name
[tPath] :: TargetSynthesis tag v x t -> String
[tTemplates] :: TargetSynthesis tag v x t -> [FilePath]

-- | number of simulation and testbench cycles
[tSimulationCycleN] :: TargetSynthesis tag v x t -> Int

-- | source code format type
[tSourceCodeType] :: TargetSynthesis tag v x t -> FrontendType
runTargetSynthesis :: (Bounded t, Suffix v1, Hashable v1, UnitTag tag, Val p, Default t, Show t, Integral t, Typeable t, Typeable v1, Ord v1, ToString v1, IsString v1) => TargetSynthesis tag v1 p t -> IO (Either String (TestbenchReport v1 p))
synthesizeTargetSystem :: (UnitTag tag, VarValTime v x t) => TargetSynthesis tag v x t -> IO (DefTree tag v x t, Either String (Project (BusNetwork tag v x t) v x))
instance NITTA.Synthesis.Types.SynthesisMethodConstraints tag v x t => Data.Default.Class.Default (NITTA.Synthesis.TargetSynthesis tag v x t)
instance (NITTA.Model.ProcessorUnits.Types.UnitTag tag, NITTA.Model.Time.VarValTime v x t) => NITTA.Model.ProcessorUnits.Types.ProcessorUnit (NITTA.Synthesis.TargetSynthesis tag v x t) v x t


module NITTA.Model.Microarchitecture.Types
data MicroarchitectureDesc tag
MicroarchitectureDesc :: [NetworkDesc tag] -> IOSynchronization -> MicroarchitectureDesc tag
[$sel:networks:MicroarchitectureDesc] :: MicroarchitectureDesc tag -> [NetworkDesc tag]
[$sel:ioSyncMode:MicroarchitectureDesc] :: MicroarchitectureDesc tag -> IOSynchronization
data NetworkDesc tag
NetworkDesc :: tag -> Text -> [UnitDesc tag] -> NetworkDesc tag
[$sel:networkTag:NetworkDesc] :: NetworkDesc tag -> tag
[$sel:valueType:NetworkDesc] :: NetworkDesc tag -> Text
[$sel:units:NetworkDesc] :: NetworkDesc tag -> [UnitDesc tag]
data UnitDesc tag
UnitDesc :: tag -> Text -> UnitDesc tag
[$sel:unitTag:UnitDesc] :: UnitDesc tag -> tag
[$sel:unitType:UnitDesc] :: UnitDesc tag -> Text
microarchitectureDesc :: forall tag v x t. Typeable x => BusNetwork tag v x t -> MicroarchitectureDesc tag
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Types.UnitDesc tag)
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Types.NetworkDesc tag)
instance GHC.Generics.Generic (NITTA.Model.Microarchitecture.Types.MicroarchitectureDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Types.MicroarchitectureDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Types.NetworkDesc tag)
instance Data.Aeson.Types.ToJSON.ToJSON tag => Data.Aeson.Types.ToJSON.ToJSON (NITTA.Model.Microarchitecture.Types.UnitDesc tag)


module NITTA.UIBackend.REST
type SynthesisAPI tag v x t = (Description "Get whole synthesis tree" :> "synthesisTree" :> Get '[JSON] (TreeView ShortNodeView)) :<|> (Description "Get synthesis tree info" :> "treeInfo" :> Get '[JSON] TreeInfo) :<|> ("node" :> Capture "sid" Sid :> (SynthesisTreeNavigationAPI tag v x t :<|> NodeInspectionAPI tag v x t :<|> TestBenchAPI v x :<|> SynthesisMethodsAPI tag v x t :<|> SynthesisPracticesAPI tag v x t))
synthesisServer :: (UnitTag tag2, Bounded b, Hashable v, Suffix v, Val x, ToJSONKey v, Label v, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, MonadIO m, Show b, Default b, Integral b, ToJSON v, ToJSON b, ToJSON tag2, Typeable b, Typeable v, Ord v, ToString v, IsString v) => BackendCtx tag2 v x b -> m (TreeView ShortNodeView) :<|> (m TreeInfo :<|> (Sid -> (m [NodeView tag2 v x b] :<|> (m (Maybe (NodeView tag2 v x b)) :<|> m [NodeView tag2 v x b])) :<|> ((m (NodeView tag2 v x b) :<|> (m (GraphStructure GraphEdge) :<|> (m (ProcessTimelines b) :<|> (m (Process b StepInfoView) :<|> ((tag2 -> m (Process b StepInfoView)) :<|> (m [UnitEndpoints tag2 v b] :<|> (m (MicroarchitectureDesc tag2) :<|> m (Debug tag2 v b)))))))) :<|> ((String -> Int -> m (TestbenchReport v x)) :<|> ((m Sid :<|> (m Sid :<|> m Sid)) :<|> (m Sid :<|> (m Sid :<|> (m Sid :<|> (Int -> m Sid)))))))))
data BackendCtx tag v x t
BackendCtx :: DefTree tag v x t -> [(v, [x])] -> String -> IO MlBackendServer -> [Text] -> BackendCtx tag v x t

-- | root synthesis node
[root] :: BackendCtx tag v x t -> DefTree tag v x t

-- | lists of received by IO values
[receivedValues] :: BackendCtx tag v x t -> [(v, [x])]
[outputPath] :: BackendCtx tag v x t -> String
[mlBackendGetter] :: BackendCtx tag v x t -> IO MlBackendServer

-- | list of node scores name. Used for ML backend mostly, but can be used
--   for any "hardcoded" scoring function.
[nodeScores] :: BackendCtx tag v x t -> [Text]
data UnitEndpoints tag v t
UnitEndpoints :: tag -> [EndpointSt v (TimeConstraint t)] -> UnitEndpoints tag v t
[$sel:unitTag:UnitEndpoints] :: UnitEndpoints tag v t -> tag
[$sel:unitEndpoints:UnitEndpoints] :: UnitEndpoints tag v t -> [EndpointSt v (TimeConstraint t)]
instance GHC.Generics.Generic (NITTA.UIBackend.REST.UnitEndpoints tag v t)
instance GHC.Generics.Generic (NITTA.UIBackend.REST.Debug tag v t)
instance (Data.Aeson.Types.ToJSON.ToJSON tag, Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON t, NITTA.Model.Time.Time t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.REST.Debug tag v t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.REST.Debug GHC.Base.String GHC.Base.String GHC.Types.Int)
instance (Data.Aeson.Types.ToJSON.ToJSON tag, Data.Aeson.Types.ToJSON.ToJSON t, Data.Aeson.Types.ToJSON.ToJSON v, NITTA.Model.Time.Time t) => Data.Aeson.Types.ToJSON.ToJSON (NITTA.UIBackend.REST.UnitEndpoints tag v t)
instance Servant.Docs.Internal.ToSample (NITTA.UIBackend.REST.UnitEndpoints GHC.Base.String GHC.Base.String GHC.Types.Int)
instance Servant.Docs.Internal.ToSample (NITTA.Model.Problems.Endpoint.EndpointSt GHC.Base.String (NITTA.Model.Time.TimeConstraint GHC.Types.Int))
instance Servant.Docs.Internal.ToSample GHC.Types.Char
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample (NITTA.Intermediate.Types.Lock tag)
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample [(Data.Text.Internal.Text, [NITTA.Intermediate.Types.Lock tag])]
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "sid" NITTA.Synthesis.Types.Sid)
instance Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture "tag" tag)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "deep" GHC.Types.Int)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "pName" GHC.Base.String)
instance Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods "loopsNumber" GHC.Types.Int)
instance Servant.Docs.Internal.ToSample NITTA.Synthesis.Types.Sid
instance NITTA.Model.Time.Time t => Servant.Docs.Internal.ToSample (NITTA.Model.ProcessorUnits.Types.Process t NITTA.UIBackend.ViewHelper.StepInfoView)
instance NITTA.Model.ProcessorUnits.Types.UnitTag tag => Servant.Docs.Internal.ToSample (NITTA.Model.Microarchitecture.Types.MicroarchitectureDesc tag)


module NITTA.UIBackend

-- | Run backend server.
backendServer :: (Suffix w, Hashable w, Val w, Bounded w, ToJSONKey w, FromHttpApiData w, UnitTag w, Label w, ToString w, IsString w, Typeable w, Typeable w, Show w, Default w, Integral w, Ord w, ToJSON w, ToJSON w, ToJSON w) => Int -> BackendCtx w w w w -> IO ()
prepareJSAPI :: Interpolatable 'True p Text => p -> FilePath -> IO ()
restDocs :: Show a => a -> String
apiPath :: FilePath

module NITTA.Model.Microarchitecture.Config
mkMicroarchitecture :: (Val v, Var x, ToJSON a, ToJSON x) => IOSynchronization -> HashMap Text a -> BusNetwork Text x v Int
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.PUConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.PUConf
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.NetworkConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.NetworkConf
instance GHC.Show.Show NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance GHC.Generics.Generic NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.MicroarchitectureConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.NetworkConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.NetworkConf
instance Data.Aeson.Types.ToJSON.ToJSON NITTA.Model.Microarchitecture.Config.PUConf
instance Data.Aeson.Types.FromJSON.FromJSON NITTA.Model.Microarchitecture.Config.PUConf
