<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- All extensions should be enabled explicitly due to doctest in this module.
<span class="lineno">    2 </span>{-# LANGUAGE DuplicateRecordFields #-}
<span class="lineno">    3 </span>{-# LANGUAGE FlexibleContexts #-}
<span class="lineno">    4 </span>{-# LANGUAGE FlexibleInstances #-}
<span class="lineno">    5 </span>{-# LANGUAGE ImportQualifiedPost #-}
<span class="lineno">    6 </span>{-# LANGUAGE LambdaCase #-}
<span class="lineno">    7 </span>{-# LANGUAGE MultiParamTypeClasses #-}
<span class="lineno">    8 </span>{-# LANGUAGE NamedFieldPuns #-}
<span class="lineno">    9 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   10 </span>{-# LANGUAGE QuasiQuotes #-}
<span class="lineno">   11 </span>{-# LANGUAGE RecordWildCards #-}
<span class="lineno">   12 </span>{-# LANGUAGE ScopedTypeVariables #-}
<span class="lineno">   13 </span>{-# LANGUAGE StandaloneDeriving #-}
<span class="lineno">   14 </span>{-# LANGUAGE TypeFamilies #-}
<span class="lineno">   15 </span>{-# LANGUAGE UndecidableInstances #-}
<span class="lineno">   16 </span>
<span class="lineno">   17 </span>-- TODO: A promising direction for the improvement is the implementation of the
<span class="lineno">   18 </span>-- accumulator into it. It allows multiplying an arbitrary number of arguments,
<span class="lineno">   19 </span>-- which will reduce the number of data transactions on the bus when multiplying
<span class="lineno">   20 </span>-- more than two variables by one function.
<span class="lineno">   21 </span>
<span class="lineno">   22 </span>-- TODO: Add assertion, which checks that all synthesis decision compliant
<span class="lineno">   23 </span>-- available options.
<span class="lineno">   24 </span>
<span class="lineno">   25 </span>{- |
<span class="lineno">   26 </span>Module      : NITTA.Model.ProcessorUnits.Multiplier
<span class="lineno">   27 </span>Description :
<span class="lineno">   28 </span>Copyright   : (c) Aleksandr Penskoi, 2020
<span class="lineno">   29 </span>License     : BSD3
<span class="lineno">   30 </span>Maintainer  : aleksandr.penskoi@gmail.com
<span class="lineno">   31 </span>Stability   : experimental
<span class="lineno">   32 </span>
<span class="lineno">   33 </span>= Processor unit
<span class="lineno">   34 </span>
<span class="lineno">   35 </span>A processor unit (PU) can be used for:
<span class="lineno">   36 </span>
<span class="lineno">   37 </span>- data storage and processing;
<span class="lineno">   38 </span>- interaction with the periphery (IO);
<span class="lineno">   39 </span>- control of a NITTA processor (special case).
<span class="lineno">   40 </span>
<span class="lineno">   41 </span>There are characterized by complicated behavior with:
<span class="lineno">   42 </span>
<span class="lineno">   43 </span>- multifunctionality;
<span class="lineno">   44 </span>- internal parallelism;
<span class="lineno">   45 </span>- superscalar;
<span class="lineno">   46 </span>- pipelining;
<span class="lineno">   47 </span>- availability of internal resources.
<span class="lineno">   48 </span>
<span class="lineno">   49 </span>The multiplier PU is one of the simplest processors because it realizes only
<span class="lineno">   50 </span>one function with sequence evaluation
<span class="lineno">   51 </span>('NITTA.Intermediate.Functions.Multiply'). Processor behavior in a specific
<span class="lineno">   52 </span>application is determined by the applied algorithm
<span class="lineno">   53 </span>('NITTA.Intermediate.DataFlow').
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>Any PU may include three components:
<span class="lineno">   56 </span>
<span class="lineno">   57 </span>- hardware - set of prepared or automatically generated hardware descriptions
<span class="lineno">   58 </span>  (@\/hdl\/multiplier@);
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>- software - set of binary files that determine:
<span class="lineno">   61 </span>
<span class="lineno">   62 </span>    - initial state and setting ;
<span class="lineno">   63 </span>
<span class="lineno">   64 </span>    - a control program;
<span class="lineno">   65 </span>
<span class="lineno">   66 </span>- PU model - CAD component that implements PU support (hardware and software
<span class="lineno">   67 </span>  generation, instance generation, computation process scheduling, testing
<span class="lineno">   68 </span>  environment, etc.).
<span class="lineno">   69 </span>
<span class="lineno">   70 </span>All three components are hardly related to each other and needed to comply
<span class="lineno">   71 </span>with each other strictly. For a deeper understanding, a PU developer should
<span class="lineno">   72 </span>understand all of its components. The multiplier model will be described
<span class="lineno">   73 </span>above.
<span class="lineno">   74 </span>
<span class="lineno">   75 </span>== Processor unit model
<span class="lineno">   76 </span>
<span class="lineno">   77 </span>A model purpose is &quot;teaching&quot; CAD how to work with the PU:
<span class="lineno">   78 </span>
<span class="lineno">   79 </span>- Which functions can be evaluated by PU? (see
<span class="lineno">   80 </span>  'NITTA.Model.ProcessorUnits.Types.ProcessorUnit')?
<span class="lineno">   81 </span>
<span class="lineno">   82 </span>- How to control PU for evaluating specific functions (see
<span class="lineno">   83 </span>  'NITTA.Model.ProcessorUnits.Types.ProcessorUnit',
<span class="lineno">   84 </span>  'NITTA.Model.ProcessorUnits.Types.Controllable')?
<span class="lineno">   85 </span>
<span class="lineno">   86 </span>- How to translating instructions to microcode (see
<span class="lineno">   87 </span>  'NITTA.Model.ProcessorUnits.Types.UnambiguouslyDecode')?
<span class="lineno">   88 </span>
<span class="lineno">   89 </span>- What are the options of PU synthesis decision available? (see
<span class="lineno">   90 </span>  'NITTA.Model.Problems.Types.ProcessorUnit',
<span class="lineno">   91 </span>  'NITTA.Model.Problems.Types.EndpointDT'):
<span class="lineno">   92 </span>
<span class="lineno">   93 </span>    - push variable to the PU ('NITTA.Model.Problems.Endpoint.Target');
<span class="lineno">   94 </span>
<span class="lineno">   95 </span>    - pull at least one variable from the PU ('NITTA.Model.Problems.Endpoint.Source').
<span class="lineno">   96 </span>
<span class="lineno">   97 </span>The basis of a PU model is a data structure that represents:
<span class="lineno">   98 </span>
<span class="lineno">   99 </span>- PU state during computation process scheduling;
<span class="lineno">  100 </span>
<span class="lineno">  101 </span>- process description (full or fragment), which can be translated to microcode.
<span class="lineno">  102 </span>
<span class="lineno">  103 </span>Exactly around this data structure, all algorithmic part of the PU model is
<span class="lineno">  104 </span>developed. The types of the following variables parametrize the data structure:
<span class="lineno">  105 </span>
<span class="lineno">  106 </span>- @v@ - variable id (usually 'String');
<span class="lineno">  107 </span>
<span class="lineno">  108 </span>- @x@ - a type of processed value (see 'NITTA.Intermediate.Value.Val');
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>- @t@ - time moment id (usually 'Int').
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>= Multiplier processor unit
<span class="lineno">  113 </span>
<span class="lineno">  114 </span>The multiplier processor unit can evaluate the following function type:
<span class="lineno">  115 </span>
<span class="lineno">  116 </span>- 'NITTA.Intermediate.Functions.Multiply'.
<span class="lineno">  117 </span>
<span class="lineno">  118 </span>Only one function can be processed in one moment, and its execution cannot be
<span class="lineno">  119 </span>interrupted.
<span class="lineno">  120 </span>
<span class="lineno">  121 </span>This module should be considered as a tutorial for the development of other
<span class="lineno">  122 </span>models of processor units. Its source code is written almost in literature
<span class="lineno">  123 </span>style, so we recommend to continue reading within the source code.
<span class="lineno">  124 </span>
<span class="lineno">  125 </span>== Interaction with multiplier processor unit
<span class="lineno">  126 </span>
<span class="lineno">  127 </span>We will consider the example of the computation process scheduling for one
<span class="lineno">  128 </span>function. To do this, we need to start GHCi interpreter by executing `stack
<span class="lineno">  129 </span>repl` command from the project directory. After that:
<span class="lineno">  130 </span>
<span class="lineno">  131 </span>@
<span class="lineno">  132 </span>&gt; :l NITTA.Model.ProcessorUnits.Multiplier
<span class="lineno">  133 </span>[ 1 of 30] Compiling NITTA.Intermediate.Value ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Value.hs, interpreted )
<span class="lineno">  134 </span>[ 2 of 30] Compiling NITTA.Intermediate.Variable ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Variable.hs, interpreted )
<span class="lineno">  135 </span>[ 3 of 30] Compiling NITTA.Intermediate.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Types.hs, interpreted )
<span class="lineno">  136 </span>[ 4 of 30] Compiling NITTA.Model.Problems.Binding ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsBinding.hs, interpreted )
<span class="lineno">  137 </span>[ 5 of 30] Compiling NITTA.Model.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Types.hs, interpreted )
<span class="lineno">  138 </span>[ 6 of 30] Compiling NITTA.Model.Problems.Endpoint ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsEndpoint.hs, interpreted )
<span class="lineno">  139 </span>[ 7 of 30] Compiling NITTA.Model.Problems.Dataflow ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsDataflow.hs, interpreted )
<span class="lineno">  140 </span>[ 8 of 30] Compiling NITTA.Project.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Types.hs, interpreted )
<span class="lineno">  141 </span>[ 9 of 30] Compiling NITTA.Utils.Base ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/Base.hs, interpreted )
<span class="lineno">  142 </span>[10 of 30] Compiling NITTA.Intermediate.Functions.Accum ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediateFunctionsAccum.hs, interpreted )
<span class="lineno">  143 </span>[11 of 30] Compiling NITTA.Intermediate.Functions ( UserspenskoiDocumentsnitta-corpnittasrcNITTAIntermediate/Functions.hs, interpreted )
<span class="lineno">  144 </span>[12 of 30] Compiling NITTA.Model.Problems.Refactor ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsRefactor.hs, interpreted )
<span class="lineno">  145 </span>[13 of 30] Compiling NITTA.Model.Problems.Whole ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProblemsWhole.hs, interpreted )
<span class="lineno">  146 </span>[14 of 30] Compiling NITTA.Model.Problems ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModel/Problems.hs, interpreted )
<span class="lineno">  147 </span>[15 of 30] Compiling NITTA.Utils.CodeFormat ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/CodeFormat.hs, interpreted )
<span class="lineno">  148 </span>[16 of 30] Compiling NITTA.Model.ProcessorUnits.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsTypes.hs, interpreted )
<span class="lineno">  149 </span>[17 of 30] Compiling NITTA.Utils      ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils.hs, interpreted )
<span class="lineno">  150 </span>[18 of 30] Compiling NITTA.Project.VerilogSnippets ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Snippets.hs, interpreted )
<span class="lineno">  151 </span>[19 of 30] Compiling NITTA.Project.Implementation ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Implementation.hs, interpreted )
<span class="lineno">  152 </span>[20 of 30] Compiling NITTA.Project.Parts.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsUtils.hs, interpreted )
<span class="lineno">  153 </span>[21 of 30] Compiling NITTA.Project.TestBench ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTestBench.hs, interpreted )
<span class="lineno">  154 </span>[22 of 30] Compiling NITTA.Project.Parts.TargetSystem ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsTargetSystem.hs, interpreted )
<span class="lineno">  155 </span>[23 of 30] Compiling NITTA.Project.Parts.Icarus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsIcarus.hs, interpreted )
<span class="lineno">  156 </span>[24 of 30] Compiling NITTA.Model.Networks.Types ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksTypes.hs, interpreted )
<span class="lineno">  157 </span>[25 of 30] Compiling NITTA.Utils.ProcessDescription ( UserspenskoiDocumentsnitta-corpnittasrcNITTAUtils/ProcessDescription.hs, interpreted )
<span class="lineno">  158 </span>[26 of 30] Compiling NITTA.Model.Networks.Bus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelNetworksBus.hs, interpreted )
<span class="lineno">  159 </span>[27 of 30] Compiling NITTA.Project.Parts.Quartus ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProjectPartsQuartus.hs, interpreted )
<span class="lineno">  160 </span>[28 of 30] Compiling NITTA.Project.Utils ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject/Utils.hs, interpreted )
<span class="lineno">  161 </span>[29 of 30] Compiling NITTA.Project    ( UserspenskoiDocumentsnitta-corpnittasrcNITTAProject.hs, interpreted )
<span class="lineno">  162 </span>[30 of 30] Compiling NITTA.Model.ProcessorUnits.Multiplier ( UserspenskoiDocumentsnitta-corpnittasrcNITTAModelProcessorUnitsMultiplier.hs, interpreted )
<span class="lineno">  163 </span>Ok, 30 modules loaded.
<span class="lineno">  164 </span>&gt; :module +NITTA.Model.ProcessorUnits.Types NITTA.Intermediate.Functions Numeric.Interval.NonEmpty Data.Set Prettyprinter.Render.Text
<span class="lineno">  165 </span>&gt; :set prompt &quot;ESC[34mλ&gt; ESC[m&quot;
<span class="lineno">  166 </span>@
<span class="lineno">  167 </span>
<span class="lineno">  168 </span>Now create the function and multiplier model initial state. Unfortunately, it
<span class="lineno">  169 </span>is not enough information for GHC deduction of its type, so let's define its
<span class="lineno">  170 </span>implicitly.
<span class="lineno">  171 </span>
<span class="lineno">  172 </span>&gt;&gt;&gt; :module +Prettyprinter.Render.Text
<span class="lineno">  173 </span>&gt;&gt;&gt; let f = F.multiply &quot;a&quot; &quot;b&quot; [&quot;c&quot;, &quot;d&quot;] :: F String Int
<span class="lineno">  174 </span>&gt;&gt;&gt; f
<span class="lineno">  175 </span>a * b = c = d
<span class="lineno">  176 </span>&gt;&gt;&gt; let st0 = multiplier True :: Multiplier String Int Int
<span class="lineno">  177 </span>&gt;&gt;&gt; putDoc $ pretty st0
<span class="lineno">  178 </span>Multiplier:
<span class="lineno">  179 </span>    remain: []
<span class="lineno">  180 </span>    targets: []
<span class="lineno">  181 </span>    sources: []
<span class="lineno">  182 </span>    currentWork: Nothing
<span class="lineno">  183 </span>    isMocked: True
<span class="lineno">  184 </span>    Process:
<span class="lineno">  185 </span>        steps:
<span class="lineno">  186 </span>        relations:
<span class="lineno">  187 </span>        nextTick: 0
<span class="lineno">  188 </span>        nextUid: 0
<span class="lineno">  189 </span>&gt;&gt;&gt; endpointOptions st0
<span class="lineno">  190 </span>[]
<span class="lineno">  191 </span>
<span class="lineno">  192 </span>Bind a function to the multiplier unit. This operation could be executed at
<span class="lineno">  193 </span>any time of working with a model, including when a computation process is
<span class="lineno">  194 </span>fully scheduled (new work can be added). The main rules are: 1) if work is
<span class="lineno">  195 </span>fully scheduled, then it is necessary to perform it, and any part of it
<span class="lineno">  196 </span>cannot be &quot;lost&quot; inside the model; 2) if a unit has its internal resources,
<span class="lineno">  197 </span>there should be enough to finish schedule, even it is inefficient.
<span class="lineno">  198 </span>
<span class="lineno">  199 </span>&gt;&gt;&gt; let Right st1 = tryBind f st0
<span class="lineno">  200 </span>&gt;&gt;&gt; putDoc $ pretty st1
<span class="lineno">  201 </span>Multiplier:
<span class="lineno">  202 </span>    remain: [a * b = c = d]
<span class="lineno">  203 </span>    targets: []
<span class="lineno">  204 </span>    sources: []
<span class="lineno">  205 </span>    currentWork: Nothing
<span class="lineno">  206 </span>    isMocked: True
<span class="lineno">  207 </span>    Process:
<span class="lineno">  208 </span>        steps:
<span class="lineno">  209 </span>        relations:
<span class="lineno">  210 </span>        nextTick: 0
<span class="lineno">  211 </span>        nextUid: 0
<span class="lineno">  212 </span>&gt;&gt;&gt; endpointOptions st1
<span class="lineno">  213 </span>[?Target a@(0..INF /P 1..INF),?Target b@(0..INF /P 1..INF)]
<span class="lineno">  214 </span>
<span class="lineno">  215 </span>As we can see, after binding, we have two different options of computational
<span class="lineno">  216 </span>process scheduling that match different argument loading sequences: @a@ or
<span class="lineno">  217 </span>@b@. We can see that they are similar from an execution sequence point of
<span class="lineno">  218 </span>view: loading can be started from 0 tick or after an arbitrary delay; for
<span class="lineno">  219 </span>loading of one argument needed only one tick, but it can continue for an
<span class="lineno">  220 </span>arbitrary time. Choose the variant.
<span class="lineno">  221 </span>
<span class="lineno">  222 </span>&gt;&gt;&gt; let st2 = endpointDecision st1 $ EndpointSt (Target &quot;a&quot;) (0...2)
<span class="lineno">  223 </span>&gt;&gt;&gt; putDoc $ pretty st2
<span class="lineno">  224 </span>Multiplier:
<span class="lineno">  225 </span>    remain: []
<span class="lineno">  226 </span>    targets: [&quot;b&quot;]
<span class="lineno">  227 </span>    sources: [&quot;c&quot;,&quot;d&quot;]
<span class="lineno">  228 </span>    currentWork: Just a * b = c = d
<span class="lineno">  229 </span>    isMocked: True
<span class="lineno">  230 </span>    Process:
<span class="lineno">  231 </span>        steps:
<span class="lineno">  232 </span>            0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
<span class="lineno">  233 </span>            1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
<span class="lineno">  234 </span>        relations:
<span class="lineno">  235 </span>            0) Vertical {vUp = 0, vDown = 1}
<span class="lineno">  236 </span>        nextTick: 3
<span class="lineno">  237 </span>        nextUid: 2
<span class="lineno">  238 </span>&gt;&gt;&gt; mapM_ print $ endpointOptions st2
<span class="lineno">  239 </span>?Target b@(3..INF /P 1..INF)
<span class="lineno">  240 </span>&gt;&gt;&gt; let st3 = endpointDecision st2 $ EndpointSt (Target &quot;b&quot;) (3...3)
<span class="lineno">  241 </span>&gt;&gt;&gt; putDoc $ pretty st3
<span class="lineno">  242 </span>Multiplier:
<span class="lineno">  243 </span>    remain: []
<span class="lineno">  244 </span>    targets: []
<span class="lineno">  245 </span>    sources: [&quot;c&quot;,&quot;d&quot;]
<span class="lineno">  246 </span>    currentWork: Just a * b = c = d
<span class="lineno">  247 </span>    isMocked: True
<span class="lineno">  248 </span>    Process:
<span class="lineno">  249 </span>        steps:
<span class="lineno">  250 </span>            0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
<span class="lineno">  251 </span>            1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
<span class="lineno">  252 </span>            2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
<span class="lineno">  253 </span>            3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
<span class="lineno">  254 </span>        relations:
<span class="lineno">  255 </span>            0) Vertical {vUp = 2, vDown = 3}
<span class="lineno">  256 </span>            1) Vertical {vUp = 0, vDown = 1}
<span class="lineno">  257 </span>        nextTick: 4
<span class="lineno">  258 </span>        nextUid: 4
<span class="lineno">  259 </span>&gt;&gt;&gt; mapM_ print $ endpointOptions st3
<span class="lineno">  260 </span>?Source c,d@(6..INF /P 1..INF)
<span class="lineno">  261 </span>
<span class="lineno">  262 </span>After loading both arguments, we can see that the next option is unloading
<span class="lineno">  263 </span>@c@ and @d@ variables. Note, these variables can be unloaded either
<span class="lineno">  264 </span>concurrently or sequentially (for details, see how the multiplier works
<span class="lineno">  265 </span>inside). Consider the second option:
<span class="lineno">  266 </span>
<span class="lineno">  267 </span>&gt;&gt;&gt; let st4 = endpointDecision st3 $ EndpointSt (Source $ S.fromList [&quot;c&quot;]) (6...6)
<span class="lineno">  268 </span>&gt;&gt;&gt; putDoc $ pretty st4
<span class="lineno">  269 </span>Multiplier:
<span class="lineno">  270 </span>    remain: []
<span class="lineno">  271 </span>    targets: []
<span class="lineno">  272 </span>    sources: [&quot;d&quot;]
<span class="lineno">  273 </span>    currentWork: Just a * b = c = d
<span class="lineno">  274 </span>    isMocked: True
<span class="lineno">  275 </span>    Process:
<span class="lineno">  276 </span>        steps:
<span class="lineno">  277 </span>            0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
<span class="lineno">  278 </span>            1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
<span class="lineno">  279 </span>            2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
<span class="lineno">  280 </span>            3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
<span class="lineno">  281 </span>            4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
<span class="lineno">  282 </span>            5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
<span class="lineno">  283 </span>        relations:
<span class="lineno">  284 </span>            0) Vertical {vUp = 4, vDown = 5}
<span class="lineno">  285 </span>            1) Vertical {vUp = 2, vDown = 3}
<span class="lineno">  286 </span>            2) Vertical {vUp = 0, vDown = 1}
<span class="lineno">  287 </span>        nextTick: 7
<span class="lineno">  288 </span>        nextUid: 6
<span class="lineno">  289 </span>&gt;&gt;&gt; mapM_ print $ endpointOptions st4
<span class="lineno">  290 </span>?Source d@(7..INF /P 1..INF)
<span class="lineno">  291 </span>&gt;&gt;&gt; let st5 = endpointDecision st4 $ EndpointSt (Source $ S.fromList [&quot;d&quot;]) (7...7)
<span class="lineno">  292 </span>&gt;&gt;&gt; putDoc $ pretty st5
<span class="lineno">  293 </span>Multiplier:
<span class="lineno">  294 </span>    remain: []
<span class="lineno">  295 </span>    targets: []
<span class="lineno">  296 </span>    sources: []
<span class="lineno">  297 </span>    currentWork: Nothing
<span class="lineno">  298 </span>    isMocked: True
<span class="lineno">  299 </span>    Process:
<span class="lineno">  300 </span>        steps:
<span class="lineno">  301 </span>            0) Step {pID = 0, pInterval = 0 ... 2, pDesc = Endpoint: Target a}
<span class="lineno">  302 </span>            1) Step {pID = 1, pInterval = 0 ... 2, pDesc = Instruction: Load}
<span class="lineno">  303 </span>            2) Step {pID = 2, pInterval = 3 ... 3, pDesc = Endpoint: Target b}
<span class="lineno">  304 </span>            3) Step {pID = 3, pInterval = 3 ... 3, pDesc = Instruction: Load}
<span class="lineno">  305 </span>            4) Step {pID = 4, pInterval = 6 ... 6, pDesc = Endpoint: Source c}
<span class="lineno">  306 </span>            5) Step {pID = 5, pInterval = 6 ... 6, pDesc = Instruction: Out}
<span class="lineno">  307 </span>            6) Step {pID = 6, pInterval = 7 ... 7, pDesc = Endpoint: Source d}
<span class="lineno">  308 </span>            7) Step {pID = 7, pInterval = 7 ... 7, pDesc = Instruction: Out}
<span class="lineno">  309 </span>            8) Step {pID = 8, pInterval = 0 ... 7, pDesc = Intermediate: a * b = c = d}
<span class="lineno">  310 </span>        relations:
<span class="lineno">  311 </span>            0) Vertical {vUp = 8, vDown = 6}
<span class="lineno">  312 </span>            1) Vertical {vUp = 8, vDown = 4}
<span class="lineno">  313 </span>            2) Vertical {vUp = 8, vDown = 2}
<span class="lineno">  314 </span>            3) Vertical {vUp = 8, vDown = 0}
<span class="lineno">  315 </span>            4) Vertical {vUp = 6, vDown = 7}
<span class="lineno">  316 </span>            5) Vertical {vUp = 4, vDown = 5}
<span class="lineno">  317 </span>            6) Vertical {vUp = 2, vDown = 3}
<span class="lineno">  318 </span>            7) Vertical {vUp = 0, vDown = 1}
<span class="lineno">  319 </span>        nextTick: 8
<span class="lineno">  320 </span>        nextUid: 9
<span class="lineno">  321 </span>&gt;&gt;&gt; endpointOptions st5
<span class="lineno">  322 </span>[]
<span class="lineno">  323 </span>
<span class="lineno">  324 </span>All options of computing process scheduling are run out. All bound functions
<span class="lineno">  325 </span>are planned. Further microcode can be generated, which can be organizing the
<span class="lineno">  326 </span>described computational process on the multiplier.
<span class="lineno">  327 </span>-}
<span class="lineno">  328 </span>module NITTA.Model.ProcessorUnits.Multiplier (
<span class="lineno">  329 </span>    multiplier,
<span class="lineno">  330 </span>    Multiplier,
<span class="lineno">  331 </span>    Ports (..),
<span class="lineno">  332 </span>    IOPorts (..),
<span class="lineno">  333 </span>) where
<span class="lineno">  334 </span>
<span class="lineno">  335 </span>import Control.Monad (when)
<span class="lineno">  336 </span>import Data.Default
<span class="lineno">  337 </span>import Data.List (find, partition, (\\))
<span class="lineno">  338 </span>import Data.Maybe
<span class="lineno">  339 </span>import Data.Set qualified as S
<span class="lineno">  340 </span>import Data.String.Interpolate
<span class="lineno">  341 </span>import Data.String.ToString
<span class="lineno">  342 </span>import NITTA.Intermediate.Functions qualified as F
<span class="lineno">  343 </span>import NITTA.Intermediate.Types
<span class="lineno">  344 </span>import NITTA.Model.Problems
<span class="lineno">  345 </span>import NITTA.Model.ProcessorUnits.Types
<span class="lineno">  346 </span>import NITTA.Model.Time
<span class="lineno">  347 </span>import NITTA.Project
<span class="lineno">  348 </span>import NITTA.Utils
<span class="lineno">  349 </span>import NITTA.Utils.ProcessDescription
<span class="lineno">  350 </span>import Numeric.Interval.NonEmpty (inf, sup, (...))
<span class="lineno">  351 </span>import Prettyprinter
<span class="lineno">  352 </span>
<span class="lineno">  353 </span>{- | It is a PU model state representation, which describes each state of
<span class="lineno">  354 </span>synthesis model for that PU.
<span class="lineno">  355 </span>-}
<span class="lineno">  356 </span>data Multiplier v x t = Multiplier
<span class="lineno">  357 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">remain</span></span></span> :: [F v x]
<span class="lineno">  358 </span>    {- ^ List of the assigned but not processed functions. To execute a
<span class="lineno">  359 </span>    function:
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>    - removing the function from this list;
<span class="lineno">  362 </span>
<span class="lineno">  363 </span>    - transfering information from function to 'targets' and 'sources'
<span class="lineno">  364 </span>    fields.
<span class="lineno">  365 </span>
<span class="lineno">  366 </span>    An assigned function can be executed in random order.
<span class="lineno">  367 </span>    -}
<span class="lineno">  368 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">targets</span></span></span> :: [v]
<span class="lineno">  369 </span>    {- ^ List of variables, which is needed to push to the PU for current
<span class="lineno">  370 </span>    function evaluation.
<span class="lineno">  371 </span>    -}
<span class="lineno">  372 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sources</span></span></span> :: [v]
<span class="lineno">  373 </span>    {- ^ List of variables, which is needed to pull from PU for current
<span class="lineno">  374 </span>    function evaluation. Pull order is arbitrary. All pulled variables
<span class="lineno">  375 </span>    correspond to the same value (same result).
<span class="lineno">  376 </span>    -}
<span class="lineno">  377 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">currentWork</span></span></span> :: Maybe (F v x)
<span class="lineno">  378 </span>    -- ^ Current work, if some function is executed.
<span class="lineno">  379 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">process_</span></span></span> :: Process t (StepInfo v x t)
<span class="lineno">  380 </span>    {- ^ Description of scheduled computation process
<span class="lineno">  381 </span>    ('NITTA.Model.ProcessorUnits.Types').
<span class="lineno">  382 </span>    -}
<span class="lineno">  383 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">isMocked</span></span></span> :: Bool
<span class="lineno">  384 </span>    {- ^ HDL implementation of PU contains a multiplier IP core from Altera.
<span class="lineno">  385 </span>    Icarus Verilog can not simulate it. If `isMocked` is set, a target
<span class="lineno">  386 </span>    system will be contained non-synthesizable implementation of that
<span class="lineno">  387 </span>    IP-core.
<span class="lineno">  388 </span>    -}
<span class="lineno">  389 </span>    }
<span class="lineno">  390 </span>
<span class="lineno">  391 </span>instance VarValTime v x t =&gt; Pretty (Multiplier v x t) where
<span class="lineno">  392 </span>    <span class="decl"><span class="nottickedoff">pretty Multiplier{remain, targets, sources, currentWork, process_, isMocked} =</span>
<span class="lineno">  393 </span><span class="spaces">        </span><span class="nottickedoff">[__i|</span>
<span class="lineno">  394 </span><span class="spaces">            </span><span class="nottickedoff">Multiplier:</span>
<span class="lineno">  395 </span><span class="spaces">                </span><span class="nottickedoff">remain: #{ remain }</span>
<span class="lineno">  396 </span><span class="spaces">                </span><span class="nottickedoff">targets: #{ map toString targets }</span>
<span class="lineno">  397 </span><span class="spaces">                </span><span class="nottickedoff">sources: #{ map toString sources }</span>
<span class="lineno">  398 </span><span class="spaces">                </span><span class="nottickedoff">currentWork: #{ currentWork }</span>
<span class="lineno">  399 </span><span class="spaces">                </span><span class="nottickedoff">isMocked: #{ isMocked }</span>
<span class="lineno">  400 </span><span class="spaces">                </span><span class="nottickedoff">#{ nest 4 $ pretty process_ }</span>
<span class="lineno">  401 </span><span class="spaces">            </span><span class="nottickedoff">|]</span></span>
<span class="lineno">  402 </span>
<span class="lineno">  403 </span>{- | Multiplier PU model constructor. Argument defines the computation unit's
<span class="lineno">  404 </span>internal organization: using multiplier IP kernel (False) or mock (True). For
<span class="lineno">  405 </span>more information, look hardware function in 'TargetSystemComponent' class.
<span class="lineno">  406 </span>-}
<span class="lineno">  407 </span><span class="decl"><span class="istickedoff">multiplier mock =</span>
<span class="lineno">  408 </span><span class="spaces">    </span><span class="istickedoff">Multiplier</span>
<span class="lineno">  409 </span><span class="spaces">        </span><span class="istickedoff">{ remain = []</span>
<span class="lineno">  410 </span><span class="spaces">        </span><span class="istickedoff">, targets = []</span>
<span class="lineno">  411 </span><span class="spaces">        </span><span class="istickedoff">, sources = []</span>
<span class="lineno">  412 </span><span class="spaces">        </span><span class="istickedoff">, currentWork = Nothing</span>
<span class="lineno">  413 </span><span class="spaces">        </span><span class="istickedoff">, process_ = def</span>
<span class="lineno">  414 </span><span class="spaces">        </span><span class="istickedoff">, isMocked = mock</span>
<span class="lineno">  415 </span><span class="spaces">        </span><span class="istickedoff">}</span></span>
<span class="lineno">  416 </span>
<span class="lineno">  417 </span>-- | Default initial state of multiplier PU model.
<span class="lineno">  418 </span>instance Time t =&gt; Default (Multiplier v x t) where
<span class="lineno">  419 </span>    <span class="decl"><span class="istickedoff">def = multiplier True</span></span>
<span class="lineno">  420 </span>
<span class="lineno">  421 </span>instance Default x =&gt; DefaultX (Multiplier v x t) x
<span class="lineno">  422 </span>
<span class="lineno">  423 </span>{- | This class is allowed to extract all bound functions. It has a very simple
<span class="lineno">  424 </span>implementation: we take process description (all planned functions), and
<span class="lineno">  425 </span>function in progress, if it is.
<span class="lineno">  426 </span>-}
<span class="lineno">  427 </span>instance Ord t =&gt; WithFunctions (Multiplier v x t) (F v x) where
<span class="lineno">  428 </span>    <span class="decl"><span class="istickedoff">functions Multiplier{process_, remain, currentWork} =</span>
<span class="lineno">  429 </span><span class="spaces">        </span><span class="istickedoff">functions process_</span>
<span class="lineno">  430 </span><span class="spaces">            </span><span class="istickedoff">++ remain</span>
<span class="lineno">  431 </span><span class="spaces">            </span><span class="istickedoff">++ maybeToList currentWork</span></span>
<span class="lineno">  432 </span>
<span class="lineno">  433 </span>{- | Tracking internal dependencies on the processed variables. It includes:
<span class="lineno">  434 </span>
<span class="lineno">  435 </span>- dependencies between inputs and outputs of currently evaluated function;
<span class="lineno">  436 </span>
<span class="lineno">  437 </span>- dependencies of all remain functions from the currently evaluated function
<span class="lineno">  438 </span>  (if it is).
<span class="lineno">  439 </span>-}
<span class="lineno">  440 </span>instance Var v =&gt; Locks (Multiplier v x t) v where
<span class="lineno">  441 </span>    <span class="decl"><span class="istickedoff">locks Multiplier{remain, sources, targets} =</span>
<span class="lineno">  442 </span><span class="spaces">        </span><span class="istickedoff">[ Lock{lockBy, locked}</span>
<span class="lineno">  443 </span><span class="spaces">        </span><span class="istickedoff">| locked &lt;- sources</span>
<span class="lineno">  444 </span><span class="spaces">        </span><span class="istickedoff">, lockBy &lt;- targets</span>
<span class="lineno">  445 </span><span class="spaces">        </span><span class="istickedoff">]</span>
<span class="lineno">  446 </span><span class="spaces">            </span><span class="istickedoff">++ [ Lock{lockBy, locked}</span>
<span class="lineno">  447 </span><span class="spaces">               </span><span class="istickedoff">| locked &lt;- concatMap (S.elems . variables) remain</span>
<span class="lineno">  448 </span><span class="spaces">               </span><span class="istickedoff">, lockBy &lt;- sources ++ targets</span>
<span class="lineno">  449 </span><span class="spaces">               </span><span class="istickedoff">]</span>
<span class="lineno">  450 </span><span class="spaces">            </span><span class="istickedoff">++ concatMap locks remain</span></span>
<span class="lineno">  451 </span>
<span class="lineno">  452 </span>{- | That type classes ('BreakLoopProblem', 'OptimizeAccumProblem',
<span class="lineno">  453 </span>'ResolveDeadlockProblem', 'ConstantFoldingProblem') describes the possibility of PU to modify an
<span class="lineno">  454 </span>algorithm. Empty implementation means that multiplier PU doesn't have such
<span class="lineno">  455 </span>possibilities.
<span class="lineno">  456 </span>-}
<span class="lineno">  457 </span>instance BreakLoopProblem (Multiplier v x t) v x
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>instance ConstantFoldingProblem (Multiplier v x t) v x
<span class="lineno">  460 </span>instance OptimizeAccumProblem (Multiplier v x t) v x
<span class="lineno">  461 </span>instance ResolveDeadlockProblem (Multiplier v x t) v x
<span class="lineno">  462 </span>
<span class="lineno">  463 </span>{- | This type class specifies how to bind functions to the PU. If it is
<span class="lineno">  464 </span>possible, @tryBind@ function will return @Right@ value with a new PU model
<span class="lineno">  465 </span>state. If not, @Left@ value with reason description. And also specify how to
<span class="lineno">  466 </span>get computation process description.
<span class="lineno">  467 </span>
<span class="lineno">  468 </span>From the CAD point of view, bind looks like:
<span class="lineno">  469 </span>
<span class="lineno">  470 </span>- CAD asks PU models: &quot;Who can evaluate this function?&quot; and get the list of
<span class="lineno">  471 </span>  possible bindings.
<span class="lineno">  472 </span>
<span class="lineno">  473 </span>- CAD, based on the different metrics (see 'NITTA.Synthesis'), the best variant
<span class="lineno">  474 </span>  is chosen.
<span class="lineno">  475 </span>
<span class="lineno">  476 </span>Binding can be done either gradually due synthesis process at the start.
<span class="lineno">  477 </span>-}
<span class="lineno">  478 </span>instance VarValTime v x t =&gt; ProcessorUnit (Multiplier v x t) v x t where
<span class="lineno">  479 </span>    <span class="decl"><span class="istickedoff">tryBind f pu@Multiplier{remain}</span>
<span class="lineno">  480 </span><span class="spaces">        </span><span class="istickedoff">| Just F.Multiply{} &lt;- castF f = Right pu{remain = f : remain}</span>
<span class="lineno">  481 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">otherwise</span> = Left $ &quot;The function is unsupported by Multiplier: &quot; ++ show f</span></span>
<span class="lineno">  482 </span>
<span class="lineno">  483 </span>    -- Unified interface for getting computation process description.
<span class="lineno">  484 </span>    <span class="decl"><span class="istickedoff">process = process_</span></span>
<span class="lineno">  485 </span>
<span class="lineno">  486 </span>-- | Execute function (set as current and remove from remain).
<span class="lineno">  487 </span><span class="decl"><span class="istickedoff">execution pu@Multiplier{targets = [], sources = [], remain} f</span>
<span class="lineno">  488 </span><span class="spaces">    </span><span class="istickedoff">| Just (F.Multiply (I a) (I b) (O c)) &lt;- castF f =</span>
<span class="lineno">  489 </span><span class="spaces">        </span><span class="istickedoff">pu</span>
<span class="lineno">  490 </span><span class="spaces">            </span><span class="istickedoff">{ targets = [a, b]</span>
<span class="lineno">  491 </span><span class="spaces">            </span><span class="istickedoff">, currentWork = Just f</span>
<span class="lineno">  492 </span><span class="spaces">            </span><span class="istickedoff">, sources = S.elems c</span>
<span class="lineno">  493 </span><span class="spaces">            </span><span class="istickedoff">, remain = remain \\ [f]</span>
<span class="lineno">  494 </span><span class="spaces">            </span><span class="istickedoff">}</span>
<span class="lineno">  495 </span><span class="spaces"></span><span class="istickedoff">execution _ _ = <span class="nottickedoff">error &quot;Multiplier: internal execution error.&quot;</span></span></span>
<span class="lineno">  496 </span>
<span class="lineno">  497 </span>{- | A computational process of PU from a hardware architectural perspective can
<span class="lineno">  498 </span>be described as a sequence of pushing and pulling values. From a synthesis
<span class="lineno">  499 </span>perspective, it is represented by 'EndpointProblem', which describes when PU
<span class="lineno">  500 </span>is a 'Source' or 'Target' of data transfers.
<span class="lineno">  501 </span>
<span class="lineno">  502 </span>Work with endpoint problem implemented by only two functions:
<span class="lineno">  503 </span>
<span class="lineno">  504 </span>__endpointOptions__ define what the possible synthesis decision is. It
<span class="lineno">  505 </span>includes three cases:
<span class="lineno">  506 </span>
<span class="lineno">  507 </span>- Not a function is executed. That means that we have options to push any
<span class="lineno">  508 </span>  input variables of remain functions.
<span class="lineno">  509 </span>
<span class="lineno">  510 </span>- The function is executed, and not all arguments are received. We have
<span class="lineno">  511 </span>  options to push remain variables.
<span class="lineno">  512 </span>
<span class="lineno">  513 </span>- The function is executed, and all arguments are received. We have options
<span class="lineno">  514 </span>  to pull the result from the multiplier, which can include several
<span class="lineno">  515 </span>  variables. These variables can be got one by one or all at once because the
<span class="lineno">  516 </span>  value will be written to the bus and read by several processor units on the
<span class="lineno">  517 </span>  hardware level.
<span class="lineno">  518 </span>
<span class="lineno">  519 </span>Note: an option don't specify moment for action but specify an available
<span class="lineno">  520 </span>interval ('NITTA.Model.Types.TimeConstraint'). That describes the interval for
<span class="lineno">  521 </span>action start and restriction on process duration.
<span class="lineno">  522 </span>
<span class="lineno">  523 </span>__endpointDecision__ defines how to apply synthesis decision to the PU model.
<span class="lineno">  524 </span>It includes three cases:
<span class="lineno">  525 </span>
<span class="lineno">  526 </span>- Push an input variable of the executed function. We need to schedule
<span class="lineno">  527 </span>  instruction for endpoint action and modify the model state.
<span class="lineno">  528 </span>
<span class="lineno">  529 </span>- Pull an output variable or variables of the executed function. We need to
<span class="lineno">  530 </span>  schedule instruction for endpoint action and modify the model state.
<span class="lineno">  531 </span>
<span class="lineno">  532 </span>- Push an input variable of a not executed function. In this case, we need to
<span class="lineno">  533 </span>  find the selected function, 'execute' it, and do a recursive call with the
<span class="lineno">  534 </span>  same decision.
<span class="lineno">  535 </span>-}
<span class="lineno">  536 </span>instance VarValTime v x t =&gt; EndpointProblem (Multiplier v x t) v t where
<span class="lineno">  537 </span>    <span class="decl"><span class="istickedoff">endpointOptions pu@Multiplier{targets}</span>
<span class="lineno">  538 </span><span class="spaces">        </span><span class="istickedoff">| not $ null targets =</span>
<span class="lineno">  539 </span><span class="spaces">            </span><span class="istickedoff">let at = nextTick pu ... maxBound</span>
<span class="lineno">  540 </span><span class="spaces">                </span><span class="istickedoff">duration = 1 ... maxBound</span>
<span class="lineno">  541 </span><span class="spaces">             </span><span class="istickedoff">in map (\v -&gt; EndpointSt (Target v) $ TimeConstraint at duration) targets</span>
<span class="lineno">  542 </span><span class="spaces">    </span><span class="istickedoff">endpointOptions Multiplier{sources, currentWork = Just f, process_}</span>
<span class="lineno">  543 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">not $ null sources</span> =</span>
<span class="lineno">  544 </span><span class="spaces">            </span><span class="istickedoff">let doneAt = inputsPushedAt process_ f + 3</span>
<span class="lineno">  545 </span><span class="spaces">                </span><span class="istickedoff">at = max doneAt (nextTick process_) ... maxBound</span>
<span class="lineno">  546 </span><span class="spaces">                </span><span class="istickedoff">duration = 1 ... maxBound</span>
<span class="lineno">  547 </span><span class="spaces">             </span><span class="istickedoff">in [EndpointSt (Source $ S.fromList sources) $ TimeConstraint at duration]</span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="istickedoff">endpointOptions pu@Multiplier{remain} = concatMap (endpointOptions . execution pu) remain</span></span>
<span class="lineno">  549 </span>
<span class="lineno">  550 </span>    <span class="decl"><span class="istickedoff">endpointDecision pu@Multiplier{targets} d@EndpointSt{epRole = Target v, epAt}</span>
<span class="lineno">  551 </span><span class="spaces">        </span><span class="istickedoff">| not $ null targets</span>
<span class="lineno">  552 </span><span class="spaces">        </span><span class="istickedoff">, ([_], targets') &lt;- partition (== v) targets</span>
<span class="lineno">  553 </span><span class="spaces">        </span><span class="istickedoff">, --  Computation process planning is carried out.</span>
<span class="lineno">  554 </span><span class="spaces">          </span><span class="istickedoff">let process_' = execSchedule pu $ do</span>
<span class="lineno">  555 </span><span class="spaces">                </span><span class="istickedoff">-- this is required for correct work of automatically generated tests,</span>
<span class="lineno">  556 </span><span class="spaces">                </span><span class="istickedoff">-- that takes information about time from Process</span>
<span class="lineno">  557 </span><span class="spaces">                </span><span class="istickedoff">scheduleEndpoint d $ scheduleInstructionUnsafe epAt Load =</span>
<span class="lineno">  558 </span><span class="spaces">            </span><span class="istickedoff">pu</span>
<span class="lineno">  559 </span><span class="spaces">                </span><span class="istickedoff">{ process_ = process_'</span>
<span class="lineno">  560 </span><span class="spaces">                </span><span class="istickedoff">, -- The remainder of the work is saved for the next loop</span>
<span class="lineno">  561 </span><span class="spaces">                  </span><span class="istickedoff">targets = targets'</span>
<span class="lineno">  562 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno">  563 </span><span class="spaces">    </span><span class="istickedoff">endpointDecision pu@Multiplier{targets = [], sources, currentWork = Just f, process_} d@EndpointSt{epRole = Source v, epAt}</span>
<span class="lineno">  564 </span><span class="spaces">        </span><span class="istickedoff">| <span class="tickonlytrue">not $ null sources</span></span>
<span class="lineno">  565 </span><span class="spaces">        </span><span class="istickedoff">, let sources' = sources \\ S.elems v</span>
<span class="lineno">  566 </span><span class="spaces">        </span><span class="istickedoff">, <span class="tickonlytrue">sources' /= sources</span></span>
<span class="lineno">  567 </span><span class="spaces">        </span><span class="istickedoff">, let a = inf $ stepsInterval $ relatedEndpoints process_ $ variables f</span>
<span class="lineno">  568 </span><span class="spaces">        </span><span class="istickedoff">, -- Compututation process planning is carring on.</span>
<span class="lineno">  569 </span><span class="spaces">          </span><span class="istickedoff">let process_' = execSchedule pu $ do</span>
<span class="lineno">  570 </span><span class="spaces">                </span><span class="istickedoff">endpoints &lt;- scheduleEndpoint d $ scheduleInstructionUnsafe epAt Out</span>
<span class="lineno">  571 </span><span class="spaces">                </span><span class="istickedoff">when (null sources') $ do</span>
<span class="lineno">  572 </span><span class="spaces">                    </span><span class="istickedoff">-- Set up the vertical relantions between functional unit</span>
<span class="lineno">  573 </span><span class="spaces">                    </span><span class="istickedoff">-- and related to that data sending.</span>
<span class="lineno">  574 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  575 </span><span class="spaces">                    </span><span class="istickedoff">-- FIXME: here ([]) you can see the source of error.</span>
<span class="lineno">  576 </span><span class="spaces">                    </span><span class="istickedoff">-- Function don't connected to bind step. It should be fixed.</span>
<span class="lineno">  577 </span><span class="spaces">                    </span><span class="istickedoff">scheduleFunctionFinish_ [] f $ a ... sup epAt</span>
<span class="lineno">  578 </span><span class="spaces">                </span><span class="istickedoff">-- this is needed to correct work of automatically generated tests</span>
<span class="lineno">  579 </span><span class="spaces">                </span><span class="istickedoff">-- that takes time about time from Process</span>
<span class="lineno">  580 </span><span class="spaces">                </span><span class="istickedoff">return <span class="nottickedoff">endpoints</span> =</span>
<span class="lineno">  581 </span><span class="spaces">            </span><span class="istickedoff">pu</span>
<span class="lineno">  582 </span><span class="spaces">                </span><span class="istickedoff">{ process_ = process_'</span>
<span class="lineno">  583 </span><span class="spaces">                </span><span class="istickedoff">, -- In case if not all variables what asked - remaining are saved.</span>
<span class="lineno">  584 </span><span class="spaces">                  </span><span class="istickedoff">sources = sources'</span>
<span class="lineno">  585 </span><span class="spaces">                </span><span class="istickedoff">, -- if all of works is done, then time when result is ready,</span>
<span class="lineno">  586 </span><span class="spaces">                  </span><span class="istickedoff">-- current work and data transfering, what is done is the current function is reset.</span>
<span class="lineno">  587 </span><span class="spaces">                  </span><span class="istickedoff">currentWork = if null sources' then Nothing else Just f</span>
<span class="lineno">  588 </span><span class="spaces">                </span><span class="istickedoff">}</span>
<span class="lineno">  589 </span><span class="spaces">    </span><span class="istickedoff">endpointDecision pu@Multiplier{targets = [], sources = [], remain} d</span>
<span class="lineno">  590 </span><span class="spaces">        </span><span class="istickedoff">| let v = oneOf $ variables d</span>
<span class="lineno">  591 </span><span class="spaces">        </span><span class="istickedoff">, Just f &lt;- find (\f -&gt; v `S.member` variables f) remain =</span>
<span class="lineno">  592 </span><span class="spaces">            </span><span class="istickedoff">endpointDecision (execution pu f) d</span>
<span class="lineno">  593 </span><span class="spaces">    </span><span class="istickedoff">-- If something went wrong.</span>
<span class="lineno">  594 </span><span class="spaces">    </span><span class="istickedoff">endpointDecision pu d = <span class="nottickedoff">error [i|incorrect decision #{ d } for #{ pretty pu }|]</span></span></span>
<span class="lineno">  595 </span>
<span class="lineno">  596 </span>{- | For each PU, we can specify the instruction set and microcode, which allows
<span class="lineno">  597 </span>us to control the PU at the hardware level.
<span class="lineno">  598 </span>
<span class="lineno">  599 </span>- instructions set describes a computation process from a programmer point of
<span class="lineno">  600 </span>  view;
<span class="lineno">  601 </span>
<span class="lineno">  602 </span>- microcode describes the structure of processors that controls signals.
<span class="lineno">  603 </span>
<span class="lineno">  604 </span>The implementation had the internal register, which allows us to simply push the
<span class="lineno">  605 </span>data in the unit, without any specification of argument position. It will be
<span class="lineno">  606 </span>always a sequence of the first and second arguments.
<span class="lineno">  607 </span>-}
<span class="lineno">  608 </span>instance Controllable (Multiplier v x t) where
<span class="lineno">  609 </span>    data Instruction (Multiplier v x t)
<span class="lineno">  610 </span>        = Load
<span class="lineno">  611 </span>        | Out
<span class="lineno">  612 </span>        deriving (<span class="decl"><span class="istickedoff">Show</span></span>)
<span class="lineno">  613 </span>
<span class="lineno">  614 </span>    data Microcode (Multiplier v x t) = Microcode
<span class="lineno">  615 </span>        { -- \| Write to mUnit signal.
<span class="lineno">  616 </span>          <span class="nottickedoff"><span class="decl"><span class="nottickedoff">wrSignal</span></span></span> :: Bool
<span class="lineno">  617 </span>        , -- \| Downloading from mUnit signal.
<span class="lineno">  618 </span>          <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oeSignal</span></span></span> :: Bool
<span class="lineno">  619 </span>        }
<span class="lineno">  620 </span>        deriving (<span class="decl"><span class="nottickedoff">Show</span></span>, <span class="decl"><span class="nottickedoff">Eq</span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Ord</span></span></span></span></span></span></span></span></span></span>)
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>    <span class="decl"><span class="istickedoff">zipSignalTagsAndValues MultiplierPorts{..} Microcode{..} =</span>
<span class="lineno">  623 </span><span class="spaces">        </span><span class="istickedoff">[ (wr, Bool wrSignal)</span>
<span class="lineno">  624 </span><span class="spaces">        </span><span class="istickedoff">, (oe, Bool oeSignal)</span>
<span class="lineno">  625 </span><span class="spaces">        </span><span class="istickedoff">]</span></span>
<span class="lineno">  626 </span>
<span class="lineno">  627 </span>    <span class="decl"><span class="istickedoff">usedPortTags MultiplierPorts{wr, oe} = [<span class="nottickedoff">wr</span>, <span class="nottickedoff">oe</span>]</span></span>
<span class="lineno">  628 </span>
<span class="lineno">  629 </span>    <span class="decl"><span class="istickedoff">takePortTags (wr : oe : _) _ = MultiplierPorts wr oe</span>
<span class="lineno">  630 </span><span class="spaces">    </span><span class="istickedoff">takePortTags _ _ = <span class="nottickedoff">error &quot;can not take port tags, tags are over&quot;</span></span></span>
<span class="lineno">  631 </span>
<span class="lineno">  632 </span>{- | Default microcode state should be equal to @nop@ function, which should be a
<span class="lineno">  633 </span>safe way to do nothing (not take a bus, not change internal PU state, etc.).
<span class="lineno">  634 </span>-}
<span class="lineno">  635 </span>instance Default (Microcode (Multiplier v x t)) where
<span class="lineno">  636 </span>    <span class="decl"><span class="istickedoff">def =</span>
<span class="lineno">  637 </span><span class="spaces">        </span><span class="istickedoff">Microcode</span>
<span class="lineno">  638 </span><span class="spaces">            </span><span class="istickedoff">{ wrSignal = False</span>
<span class="lineno">  639 </span><span class="spaces">            </span><span class="istickedoff">, oeSignal = False</span>
<span class="lineno">  640 </span><span class="spaces">            </span><span class="istickedoff">}</span></span>
<span class="lineno">  641 </span>
<span class="lineno">  642 </span>{- | Instruction and microcode should have exact matching, which allows us to
<span class="lineno">  643 </span>translate PU instructions to microcode value.
<span class="lineno">  644 </span>-}
<span class="lineno">  645 </span>instance UnambiguouslyDecode (Multiplier v x t) where
<span class="lineno">  646 </span>    <span class="decl"><span class="istickedoff">decodeInstruction Load = def{wrSignal = True}</span>
<span class="lineno">  647 </span><span class="spaces">    </span><span class="istickedoff">decodeInstruction Out = def{oeSignal = True}</span></span>
<span class="lineno">  648 </span>
<span class="lineno">  649 </span>{- | Processor unit control signal ports. In
<span class="lineno">  650 </span>'NITTA.Model.Networks.Bus.BusNetwork', these ports are directly connecting to
<span class="lineno">  651 </span>@ControlUnit@.
<span class="lineno">  652 </span>-}
<span class="lineno">  653 </span>instance Connected (Multiplier v x t) where
<span class="lineno">  654 </span>    data Ports (Multiplier v x t) = MultiplierPorts
<span class="lineno">  655 </span>        { -- \|get data from the bus (data_in)
<span class="lineno">  656 </span>          <span class="nottickedoff"><span class="decl"><span class="nottickedoff">wr</span></span></span> :: SignalTag
<span class="lineno">  657 </span>        , -- \|send result to the bus
<span class="lineno">  658 </span>          <span class="nottickedoff"><span class="decl"><span class="nottickedoff">oe</span></span></span> :: SignalTag
<span class="lineno">  659 </span>        }
<span class="lineno">  660 </span>        deriving (<span class="decl"><span class="nottickedoff">Show</span></span>)
<span class="lineno">  661 </span>
<span class="lineno">  662 </span>instance IOConnected (Multiplier v x t) where
<span class="lineno">  663 </span>    data IOPorts (Multiplier v x t) = MultiplierIO
<span class="lineno">  664 </span>        deriving (<span class="decl"><span class="nottickedoff">Show</span></span>)
<span class="lineno">  665 </span>
<span class="lineno">  666 </span>{- | Usage of PU requires some artifacts of a synthesis process:
<span class="lineno">  667 </span>
<span class="lineno">  668 </span>- Hardware implementation, which depends from 'isMocked' value:
<span class="lineno">  669 </span>
<span class="lineno">  670 </span>- Software (not needed for the multiplier because it does not have any
<span class="lineno">  671 </span>  configuration and is controlled from the network level).
<span class="lineno">  672 </span>
<span class="lineno">  673 </span>- Hardware instance in the upper structure element.
<span class="lineno">  674 </span>-}
<span class="lineno">  675 </span>instance VarValTime v x t =&gt; TargetSystemComponent (Multiplier v x t) where
<span class="lineno">  676 </span>    <span class="decl"><span class="istickedoff">moduleName _title _pu = &quot;pu_multiplier&quot;</span></span>
<span class="lineno">  677 </span>
<span class="lineno">  678 </span>    <span class="decl"><span class="istickedoff">hardware _tag Multiplier{isMocked} =</span>
<span class="lineno">  679 </span><span class="spaces">        </span><span class="istickedoff">Aggregate</span>
<span class="lineno">  680 </span><span class="spaces">            </span><span class="istickedoff">Nothing</span>
<span class="lineno">  681 </span><span class="spaces">            </span><span class="istickedoff">[ if <span class="tickonlytrue">isMocked</span></span>
<span class="lineno">  682 </span><span class="spaces">                </span><span class="istickedoff">then FromLibrary &quot;multiplier/mult_mock.v&quot;</span>
<span class="lineno">  683 </span><span class="spaces">                </span><span class="istickedoff">else <span class="nottickedoff">FromLibrary &quot;multiplier/mult_inner.v&quot;</span></span>
<span class="lineno">  684 </span><span class="spaces">            </span><span class="istickedoff">, FromLibrary &quot;multiplier/pu_multiplier.v&quot;</span>
<span class="lineno">  685 </span><span class="spaces">            </span><span class="istickedoff">]</span></span>
<span class="lineno">  686 </span>
<span class="lineno">  687 </span>    <span class="decl"><span class="istickedoff">software _ _ = Empty</span></span>
<span class="lineno">  688 </span>
<span class="lineno">  689 </span>    <span class="decl"><span class="istickedoff">hardwareInstance</span>
<span class="lineno">  690 </span><span class="spaces">        </span><span class="istickedoff">tag</span>
<span class="lineno">  691 </span><span class="spaces">        </span><span class="istickedoff">_pu</span>
<span class="lineno">  692 </span><span class="spaces">        </span><span class="istickedoff">UnitEnv</span>
<span class="lineno">  693 </span><span class="spaces">            </span><span class="istickedoff">{ sigClk</span>
<span class="lineno">  694 </span><span class="spaces">            </span><span class="istickedoff">, sigRst</span>
<span class="lineno">  695 </span><span class="spaces">            </span><span class="istickedoff">, ctrlPorts = Just MultiplierPorts{..}</span>
<span class="lineno">  696 </span><span class="spaces">            </span><span class="istickedoff">, valueIn = Just (dataIn, attrIn)</span>
<span class="lineno">  697 </span><span class="spaces">            </span><span class="istickedoff">, valueOut = Just (dataOut, attrOut)</span>
<span class="lineno">  698 </span><span class="spaces">            </span><span class="istickedoff">} =</span>
<span class="lineno">  699 </span><span class="spaces">            </span><span class="istickedoff">[__i|<span class="nottickedoff"><span class="istickedoff"></span></span></span>
<span class="lineno">  700 </span><span class="spaces">                </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">pu_multiplier \#</span></span></span>
<span class="lineno">  701 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">( .DATA_WIDTH( #{ dataWidth (def :: x) } )</span></span></span>
<span class="lineno">  702 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .ATTR_WIDTH( #{ attrWidth (def :: x) } )</span></span></span>
<span class="lineno">  703 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .SCALING_FACTOR_POWER( #{ fractionalBitSize (def :: x) } )</span></span></span>
<span class="lineno">  704 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .INVALID( 0 )</span></span></span>
<span class="lineno">  705 </span><span class="spaces">                        </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">) #{ tag }</span></span></span>
<span class="lineno">  706 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">( .clk( #{ sigClk } )</span></span></span>
<span class="lineno">  707 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .rst( #{ sigRst } )</span></span></span>
<span class="lineno">  708 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .signal_wr( #{ wr } )</span></span></span>
<span class="lineno">  709 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .data_in( #{ dataIn } )</span></span></span>
<span class="lineno">  710 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .attr_in( #{ attrIn } )</span></span></span>
<span class="lineno">  711 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .signal_oe( #{ oe } )</span></span></span>
<span class="lineno">  712 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .data_out( #{ dataOut } )</span></span></span>
<span class="lineno">  713 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">, .attr_out( #{ attrOut } )</span></span></span>
<span class="lineno">  714 </span><span class="spaces">                    </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">);</span></span></span>
<span class="lineno">  715 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff"><span class="istickedoff">|]</span></span></span>
<span class="lineno">  716 </span><span class="spaces">    </span><span class="istickedoff">hardwareInstance _title _pu _env = <span class="nottickedoff">error &quot;internal error&quot;</span></span></span>
<span class="lineno">  717 </span>
<span class="lineno">  718 </span>{- | Empty implementation of 'NITTA.Project.TestBench.IOTestBench' class
<span class="lineno">  719 </span>means that multiplier, as expected, doesn't have any IO.
<span class="lineno">  720 </span>-}
<span class="lineno">  721 </span>instance IOTestBench (Multiplier v x t) v x
<span class="lineno">  722 </span>
<span class="lineno">  723 </span>{- | The main purpose of this class is to generate autotests for PU. It allows to
<span class="lineno">  724 </span>generate testbench for the PU according to its model and scheduled computational
<span class="lineno">  725 </span>process. You can see tests in @test/Spec.hs@. Testbench contains:
<span class="lineno">  726 </span>
<span class="lineno">  727 </span>- The sequence of control signals that implement the already scheduled process.
<span class="lineno">  728 </span>
<span class="lineno">  729 </span>- The sequence of bus state checks in which we compare actual values with the
<span class="lineno">  730 </span>  results of the functional simulation.
<span class="lineno">  731 </span>-}
<span class="lineno">  732 </span>instance VarValTime v x t =&gt; Testable (Multiplier v x t) v x where
<span class="lineno">  733 </span>    <span class="decl"><span class="istickedoff">testBenchImplementation prj@Project{pName, pUnit} =</span>
<span class="lineno">  734 </span><span class="spaces">        </span><span class="istickedoff">Immediate (toString $ moduleName <span class="nottickedoff">pName</span> <span class="nottickedoff">pUnit</span> &lt;&gt; &quot;_tb.v&quot;) $</span>
<span class="lineno">  735 </span><span class="spaces">            </span><span class="istickedoff">snippetTestBench</span>
<span class="lineno">  736 </span><span class="spaces">                </span><span class="istickedoff">prj</span>
<span class="lineno">  737 </span><span class="spaces">                </span><span class="istickedoff">SnippetTestBenchConf</span>
<span class="lineno">  738 </span><span class="spaces">                    </span><span class="istickedoff">{ -- List of control signals. It is needed to initialize</span>
<span class="lineno">  739 </span><span class="spaces">                      </span><span class="istickedoff">-- registers with the same names.</span>
<span class="lineno">  740 </span><span class="spaces">                      </span><span class="istickedoff">tbcSignals = [&quot;oe&quot;, &quot;wr&quot;]</span>
<span class="lineno">  741 </span><span class="spaces">                    </span><span class="istickedoff">, -- A processor unit connects to the environment by signal</span>
<span class="lineno">  742 </span><span class="spaces">                      </span><span class="istickedoff">-- lines. In 'NITTA.Project.TestBench.tbcPorts'</span>
<span class="lineno">  743 </span><span class="spaces">                      </span><span class="istickedoff">-- describes IDs signal lines of testbench. In</span>
<span class="lineno">  744 </span><span class="spaces">                      </span><span class="istickedoff">-- 'NITTA.Project.TestBench.tbcSignalConnect' how</span>
<span class="lineno">  745 </span><span class="spaces">                      </span><span class="istickedoff">-- abstract numbers are translate to source code.</span>
<span class="lineno">  746 </span><span class="spaces">                      </span><span class="istickedoff">tbcPorts =</span>
<span class="lineno">  747 </span><span class="spaces">                        </span><span class="istickedoff">MultiplierPorts</span>
<span class="lineno">  748 </span><span class="spaces">                            </span><span class="istickedoff">{ oe = SignalTag &quot;oe&quot;</span>
<span class="lineno">  749 </span><span class="spaces">                            </span><span class="istickedoff">, wr = SignalTag &quot;wr&quot;</span>
<span class="lineno">  750 </span><span class="spaces">                            </span><span class="istickedoff">}</span>
<span class="lineno">  751 </span><span class="spaces">                    </span><span class="istickedoff">, -- Map microcode to registers in the testbench.</span>
<span class="lineno">  752 </span><span class="spaces">                      </span><span class="istickedoff">tbcMC2verilogLiteral = \Microcode{oeSignal, wrSignal} -&gt;</span>
<span class="lineno">  753 </span><span class="spaces">                        </span><span class="istickedoff">[i|oe &lt;= #{bool2verilog oeSignal};|]</span>
<span class="lineno">  754 </span><span class="spaces">                            </span><span class="istickedoff">&lt;&gt; [i| wr &lt;= #{bool2verilog wrSignal};|]</span>
<span class="lineno">  755 </span><span class="spaces">                    </span><span class="istickedoff">}</span></span>

</pre>
</body>
</html>
