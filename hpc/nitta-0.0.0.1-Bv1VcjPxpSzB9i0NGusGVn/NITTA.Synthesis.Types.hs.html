<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>{-# LANGUAGE AllowAmbiguousTypes #-}
<span class="lineno">    2 </span>{-# LANGUAGE ConstraintKinds #-}
<span class="lineno">    3 </span>{-# LANGUAGE FunctionalDependencies #-}
<span class="lineno">    4 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">    5 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">    6 </span>{-# LANGUAGE NoMonomorphismRestriction #-}
<span class="lineno">    7 </span>
<span class="lineno">    8 </span>{- |
<span class="lineno">    9 </span>Module      : NITTA.Synthesis.Types
<span class="lineno">   10 </span>Description : Synthesis tree representation
<span class="lineno">   11 </span>Copyright   : (c) Aleksandr Penskoi, 2021
<span class="lineno">   12 </span>License     : BSD3
<span class="lineno">   13 </span>Maintainer  : aleksandr.penskoi@gmail.com
<span class="lineno">   14 </span>Stability   : experimental
<span class="lineno">   15 </span>
<span class="lineno">   16 </span>Synthesis can be represented as a graph (tree), where each 'Node' describes the
<span class="lineno">   17 </span>target system 'ModelState' and each 'Edge' synthesis decision.
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>A synthesis graph is very large and calculating and storing it in memory is very
<span class="lineno">   20 </span>bad idea. Also, working with synthesis graph usually making from the specific
<span class="lineno">   21 </span>node, not from the root. As a result, synthesis graph design as a explicit lazy
<span class="lineno">   22 </span>mutable structure implemented by 'TVar'.
<span class="lineno">   23 </span>
<span class="lineno">   24 </span>From this point of view, the synthesis process is a finding of the best tree
<span class="lineno">   25 </span>leaf (lowest process duration for finished synthesis), and the best synthesis
<span class="lineno">   26 </span>method - a method which directly walks over the tree to the best leaf without
<span class="lineno">   27 </span>wrong steps.
<span class="lineno">   28 </span>-}
<span class="lineno">   29 </span>module NITTA.Synthesis.Types (
<span class="lineno">   30 </span>    SynthesisDecisionCls (..),
<span class="lineno">   31 </span>    Tree (..),
<span class="lineno">   32 </span>    SynthesisDecision (..),
<span class="lineno">   33 </span>    SynthesisState (..),
<span class="lineno">   34 </span>    SynthesisMethodConstraints,
<span class="lineno">   35 </span>    Sid (..),
<span class="lineno">   36 </span>    DefTree,
<span class="lineno">   37 </span>    SynthesisMethod,
<span class="lineno">   38 </span>    (&lt;?&gt;),
<span class="lineno">   39 </span>    targetUnit,
<span class="lineno">   40 </span>    targetDFG,
<span class="lineno">   41 </span>    defScore,
<span class="lineno">   42 </span>    mlScoreKeyPrefix,
<span class="lineno">   43 </span>) where
<span class="lineno">   44 </span>
<span class="lineno">   45 </span>import Control.Concurrent.STM (TMVar)
<span class="lineno">   46 </span>import Data.Aeson (ToJSON, toJSON)
<span class="lineno">   47 </span>import Data.Default
<span class="lineno">   48 </span>import Data.List.Split
<span class="lineno">   49 </span>import Data.Map.Strict (Map)
<span class="lineno">   50 </span>import Data.Map.Strict qualified as M
<span class="lineno">   51 </span>import Data.Set qualified as S
<span class="lineno">   52 </span>import Data.Text (Text, isPrefixOf)
<span class="lineno">   53 </span>import Data.Typeable
<span class="lineno">   54 </span>import NITTA.Intermediate.Analysis (ProcessWave)
<span class="lineno">   55 </span>import NITTA.Intermediate.Types
<span class="lineno">   56 </span>import NITTA.Model.Networks.Bus
<span class="lineno">   57 </span>import NITTA.Model.Problems.Allocation
<span class="lineno">   58 </span>import NITTA.Model.Problems.Bind
<span class="lineno">   59 </span>import NITTA.Model.Problems.Dataflow
<span class="lineno">   60 </span>import NITTA.Model.Problems.Refactor
<span class="lineno">   61 </span>import NITTA.Model.Problems.ViewHelper
<span class="lineno">   62 </span>import NITTA.Model.ProcessorUnits.Types (UnitTag)
<span class="lineno">   63 </span>import NITTA.Model.TargetSystem
<span class="lineno">   64 </span>import NITTA.Model.Time
<span class="lineno">   65 </span>import NITTA.UIBackend.ViewHelperCls
<span class="lineno">   66 </span>import NITTA.Utils.Base
<span class="lineno">   67 </span>import Servant
<span class="lineno">   68 </span>
<span class="lineno">   69 </span>-- | Default synthesis tree type.
<span class="lineno">   70 </span>type DefTree tag v x t =
<span class="lineno">   71 </span>    Tree (TargetSystem (BusNetwork tag v x t) tag v x t) tag v x t
<span class="lineno">   72 </span>
<span class="lineno">   73 </span>{- | The synthesis method is a function, which manipulates a synthesis tree. It
<span class="lineno">   74 </span>receives a node and explores it deeply by IO.
<span class="lineno">   75 </span>-}
<span class="lineno">   76 </span>type SynthesisMethod tag v x t = DefTree tag v x t -&gt; IO (DefTree tag v x t)
<span class="lineno">   77 </span>
<span class="lineno">   78 </span>{- | Shortcut for constraints in signatures of synthesis method functions.
<span class="lineno">   79 </span>This used to be (VarValTime v x t, UnitTag tag). See below for more info.
<span class="lineno">   80 </span>-}
<span class="lineno">   81 </span>type SynthesisMethodConstraints tag v x t = (VarValTimeJSON v x t, ToJSON tag, UnitTag tag)
<span class="lineno">   82 </span>
<span class="lineno">   83 </span>{- | Synthesis node ID. ID is a relative path, encoded as a sequence of an option
<span class="lineno">   84 </span>index.
<span class="lineno">   85 </span>-}
<span class="lineno">   86 </span>newtype Sid = Sid [Int]
<span class="lineno">   87 </span>
<span class="lineno">   88 </span>-- | Sid separator for @Show Sid@ and @Read Sid@.
<span class="lineno">   89 </span><span class="decl"><span class="nottickedoff">sidSep = '-'</span></span>
<span class="lineno">   90 </span>
<span class="lineno">   91 </span>instance Show Sid where
<span class="lineno">   92 </span>    <span class="decl"><span class="nottickedoff">show (Sid []) = [sidSep]</span>
<span class="lineno">   93 </span><span class="spaces">    </span><span class="nottickedoff">show (Sid is) = show' is</span>
<span class="lineno">   94 </span><span class="spaces">        </span><span class="nottickedoff">where</span>
<span class="lineno">   95 </span><span class="spaces">            </span><span class="nottickedoff">show' [] = &quot;&quot;</span>
<span class="lineno">   96 </span><span class="spaces">            </span><span class="nottickedoff">show' (x : xs) = sidSep : show x ++ show' xs</span></span>
<span class="lineno">   97 </span>
<span class="lineno">   98 </span>instance Read Sid where
<span class="lineno">   99 </span>    <span class="decl"><span class="nottickedoff">readsPrec _ [x] | x == sidSep = [(Sid [], &quot;&quot;)]</span>
<span class="lineno">  100 </span><span class="spaces">    </span><span class="nottickedoff">readsPrec d (x : xs)</span>
<span class="lineno">  101 </span><span class="spaces">        </span><span class="nottickedoff">| x == sidSep</span>
<span class="lineno">  102 </span><span class="spaces">        </span><span class="nottickedoff">, let is = map (readsPrec d) $ splitOn [sidSep] xs</span>
<span class="lineno">  103 </span><span class="spaces">        </span><span class="nottickedoff">, not $ any null is =</span>
<span class="lineno">  104 </span><span class="spaces">            </span><span class="nottickedoff">[(Sid $ map fst $ concat is, &quot;&quot;)]</span>
<span class="lineno">  105 </span><span class="spaces">    </span><span class="nottickedoff">readsPrec _ _ = []</span></span>
<span class="lineno">  106 </span>
<span class="lineno">  107 </span>instance Default Sid where
<span class="lineno">  108 </span>    <span class="decl"><span class="nottickedoff">def = Sid []</span></span>
<span class="lineno">  109 </span>
<span class="lineno">  110 </span>instance Semigroup Sid where
<span class="lineno">  111 </span>    <span class="decl"><span class="nottickedoff">(Sid a) &lt;&gt; (Sid b) = Sid (a &lt;&gt; b)</span></span>
<span class="lineno">  112 </span>
<span class="lineno">  113 </span>instance Monoid Sid where
<span class="lineno">  114 </span>    <span class="decl"><span class="nottickedoff">mempty = Sid []</span></span>
<span class="lineno">  115 </span>    <span class="decl"><span class="nottickedoff">mappend = (&lt;&gt;)</span></span>
<span class="lineno">  116 </span>
<span class="lineno">  117 </span>instance ToJSON Sid where
<span class="lineno">  118 </span>    <span class="decl"><span class="nottickedoff">toJSON sid = toJSON $ show sid</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>instance FromHttpApiData Sid where
<span class="lineno">  121 </span>    <span class="decl"><span class="nottickedoff">parseUrlPiece = Right . readText</span></span>
<span class="lineno">  122 </span>
<span class="lineno">  123 </span>-- | Synthesis tree
<span class="lineno">  124 </span>data Tree m tag v x t = Tree
<span class="lineno">  125 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sID</span></span></span> :: Sid
<span class="lineno">  126 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sState</span></span></span> :: SynthesisState m tag v x t
<span class="lineno">  127 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sDecision</span></span></span> :: SynthesisDecision (SynthesisState m tag v x t) m
<span class="lineno">  128 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sSubForestVar</span></span></span> :: TMVar [Tree m tag v x t]
<span class="lineno">  129 </span>    -- ^ lazy mutable field with different synthesis options and sub nodes
<span class="lineno">  130 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">isLeaf</span></span></span> :: Bool
<span class="lineno">  131 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">isComplete</span></span></span> :: Bool
<span class="lineno">  132 </span>    }
<span class="lineno">  133 </span>
<span class="lineno">  134 </span><span class="decl"><span class="istickedoff">targetUnit = mUnit . sTarget . sState</span></span>
<span class="lineno">  135 </span><span class="decl"><span class="istickedoff">targetDFG = mDataFlowGraph . sTarget . sState</span></span>
<span class="lineno">  136 </span>
<span class="lineno">  137 </span>data SynthesisDecision ctx m where
<span class="lineno">  138 </span>    Root :: SynthesisDecision ctx m
<span class="lineno">  139 </span>    SynthesisDecision ::
<span class="lineno">  140 </span>        (Typeable p, SynthesisDecisionCls ctx m o d p, Show d, ToJSON p, Viewable d DecisionView) =&gt;
<span class="lineno">  141 </span>        {<span class="decl"><span class="nottickedoff">option</span></span> :: o, <span class="decl"><span class="nottickedoff">decision</span></span> :: d, <span class="decl"><span class="nottickedoff">metrics</span></span> :: p, <span class="istickedoff"><span class="nottickedoff"><span class="decl"><span class="istickedoff">scores</span></span></span></span> :: Map Text Float} -&gt;
<span class="lineno">  142 </span>        SynthesisDecision ctx m
<span class="lineno">  143 </span>
<span class="lineno">  144 </span><span class="decl"><span class="istickedoff">mlScoreKeyPrefix = &quot;ml_&quot;</span></span>
<span class="lineno">  145 </span>
<span class="lineno">  146 </span>defScore :: SynthesisDecision ctx m -&gt; Float
<span class="lineno">  147 </span><span class="decl"><span class="istickedoff">defScore sDecision =</span>
<span class="lineno">  148 </span><span class="spaces">    </span><span class="istickedoff">let allScores = scores sDecision</span>
<span class="lineno">  149 </span><span class="spaces">        </span><span class="istickedoff">mlScores = filter (isPrefixOf mlScoreKeyPrefix . fst) $ M.assocs allScores</span>
<span class="lineno">  150 </span><span class="spaces">     </span><span class="istickedoff">in case mlScores of</span>
<span class="lineno">  151 </span><span class="spaces">            </span><span class="istickedoff">[] -&gt; allScores M.! &quot;default&quot;</span>
<span class="lineno">  152 </span><span class="spaces">            </span><span class="istickedoff">(_key, mlScore) : _ -&gt; <span class="nottickedoff">mlScore</span></span></span>
<span class="lineno">  153 </span>
<span class="lineno">  154 </span>class SynthesisDecisionCls ctx m o d p | ctx o -&gt; m d p where
<span class="lineno">  155 </span>    decisions :: ctx -&gt; o -&gt; [(d, m)]
<span class="lineno">  156 </span>    parameters :: ctx -&gt; o -&gt; d -&gt; p
<span class="lineno">  157 </span>    estimate :: ctx -&gt; o -&gt; d -&gt; p -&gt; Float
<span class="lineno">  158 </span>
<span class="lineno">  159 </span>data SynthesisState m tag v x t = SynthesisState
<span class="lineno">  160 </span>    { <span class="nottickedoff"><span class="decl"><span class="nottickedoff">sParent</span></span></span> :: Maybe (Tree m tag v x t)
<span class="lineno">  161 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sTarget</span></span></span> :: m
<span class="lineno">  162 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sAllocationOptions</span></span></span> :: [Allocation tag]
<span class="lineno">  163 </span>    -- ^ PU allocation options cache
<span class="lineno">  164 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sBindOptions</span></span></span> :: [Bind tag v x]
<span class="lineno">  165 </span>    -- ^ bind options cache
<span class="lineno">  166 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sResolveDeadlockOptions</span></span></span> :: [ResolveDeadlock v x]
<span class="lineno">  167 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sOptimizeAccumOptions</span></span></span> :: [OptimizeAccum v x]
<span class="lineno">  168 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sOptimizeLogicalUnitOptions</span></span></span> :: [OptimizeLogicalUnit v x]
<span class="lineno">  169 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sConstantFoldingOptions</span></span></span> :: [ConstantFolding v x]
<span class="lineno">  170 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sBreakLoopOptions</span></span></span> :: [BreakLoop v x]
<span class="lineno">  171 </span>    , <span class="istickedoff"><span class="decl"><span class="istickedoff">sDataflowOptions</span></span></span> :: [DataflowSt tag v (TimeConstraint t)]
<span class="lineno">  172 </span>    -- ^ dataflow options cache
<span class="lineno">  173 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindingAlternative</span></span></span> :: M.Map (F v x) [tag]
<span class="lineno">  174 </span>    -- ^ a map from functions to possible processor unit tags
<span class="lineno">  175 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">possibleDeadlockBinds</span></span></span> :: S.Set (F v x)
<span class="lineno">  176 </span>    -- ^ a function set, which binding may cause dead lock
<span class="lineno">  177 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">bindWaves</span></span></span> :: M.Map v Int
<span class="lineno">  178 </span>    {- ^ if algorithm will be represented as a graph, where nodes -
<span class="lineno">  179 </span>    variables of not bound functions, edges - casuality, wave is a
<span class="lineno">  180 </span>    minimal number of a step from an initial node to selected
<span class="lineno">  181 </span>    -}
<span class="lineno">  182 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">processWaves</span></span></span> :: [ProcessWave v x]
<span class="lineno">  183 </span>    -- ^ Execution waves of the algorithm. See detailed description in NITTA.Intermediate.Analysis module.
<span class="lineno">  184 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">numberOfProcessWaves</span></span></span> :: Int
<span class="lineno">  185 </span>    -- ^ Number of execution waves of the algorithm.
<span class="lineno">  186 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">numberOfDataflowOptions</span></span></span> :: Int
<span class="lineno">  187 </span>    -- ^ number of dataflow options
<span class="lineno">  188 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">transferableVars</span></span></span> :: S.Set v
<span class="lineno">  189 </span>    {- ^ a variable set, which can be transferred on the current
<span class="lineno">  190 </span>    synthesis step
<span class="lineno">  191 </span>    -}
<span class="lineno">  192 </span>    , <span class="nottickedoff"><span class="decl"><span class="nottickedoff">unitWorkloadInFunction</span></span></span> :: M.Map tag Int
<span class="lineno">  193 </span>    -- ^ dictionary with number of bound functions for each unit
<span class="lineno">  194 </span>    }
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>-- * Utils
<span class="lineno">  197 </span>
<span class="lineno">  198 </span><span class="decl"><span class="istickedoff">True &lt;?&gt; v = v</span>
<span class="lineno">  199 </span><span class="spaces"></span><span class="istickedoff">False &lt;?&gt; _ = 0</span></span>

</pre>
</body>
</html>
